/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.6.1
 * source: node/models/block.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./../../consensus/models/block_header";
import * as dependency_2 from "./../../brambl/models/transaction/io_transaction";
import * as dependency_3 from "./../../brambl/models/identifier";
import * as dependency_4 from "./../../validate/validate";
import * as pb_1 from "google-protobuf";
export namespace co.topl.node.models {
    export class BlockBody extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            transactionIds?: dependency_3.co.topl.brambl.models.TransactionId[];
            rewardTransactionId?: dependency_3.co.topl.brambl.models.TransactionId;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("transactionIds" in data && data.transactionIds != undefined) {
                    this.transactionIds = data.transactionIds;
                }
                if ("rewardTransactionId" in data && data.rewardTransactionId != undefined) {
                    this.rewardTransactionId = data.rewardTransactionId;
                }
            }
        }
        get transactionIds() {
            return pb_1.Message.getRepeatedWrapperField(this, dependency_3.co.topl.brambl.models.TransactionId, 1) as dependency_3.co.topl.brambl.models.TransactionId[];
        }
        set transactionIds(value: dependency_3.co.topl.brambl.models.TransactionId[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get rewardTransactionId() {
            return pb_1.Message.getWrapperField(this, dependency_3.co.topl.brambl.models.TransactionId, 2) as dependency_3.co.topl.brambl.models.TransactionId;
        }
        set rewardTransactionId(value: dependency_3.co.topl.brambl.models.TransactionId) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_rewardTransactionId() {
            return pb_1.Message.getField(this, 2) != null;
        }
        static fromObject(data: {
            transactionIds?: ReturnType<typeof dependency_3.co.topl.brambl.models.TransactionId.prototype.toObject>[];
            rewardTransactionId?: ReturnType<typeof dependency_3.co.topl.brambl.models.TransactionId.prototype.toObject>;
        }): BlockBody {
            const message = new BlockBody({});
            if (data.transactionIds != null) {
                message.transactionIds = data.transactionIds.map(item => dependency_3.co.topl.brambl.models.TransactionId.fromObject(item));
            }
            if (data.rewardTransactionId != null) {
                message.rewardTransactionId = dependency_3.co.topl.brambl.models.TransactionId.fromObject(data.rewardTransactionId);
            }
            return message;
        }
        toObject() {
            const data: {
                transactionIds?: ReturnType<typeof dependency_3.co.topl.brambl.models.TransactionId.prototype.toObject>[];
                rewardTransactionId?: ReturnType<typeof dependency_3.co.topl.brambl.models.TransactionId.prototype.toObject>;
            } = {};
            if (this.transactionIds != null) {
                data.transactionIds = this.transactionIds.map((item: dependency_3.co.topl.brambl.models.TransactionId) => item.toObject());
            }
            if (this.rewardTransactionId != null) {
                data.rewardTransactionId = this.rewardTransactionId.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.transactionIds.length)
                writer.writeRepeatedMessage(1, this.transactionIds, (item: dependency_3.co.topl.brambl.models.TransactionId) => item.serialize(writer));
            if (this.has_rewardTransactionId)
                writer.writeMessage(2, this.rewardTransactionId, () => this.rewardTransactionId.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): BlockBody {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new BlockBody();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.transactionIds, () => pb_1.Message.addToRepeatedWrapperField(message, 1, dependency_3.co.topl.brambl.models.TransactionId.deserialize(reader), dependency_3.co.topl.brambl.models.TransactionId));
                        break;
                    case 2:
                        reader.readMessage(message.rewardTransactionId, () => message.rewardTransactionId = dependency_3.co.topl.brambl.models.TransactionId.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): BlockBody {
            return BlockBody.deserialize(bytes);
        }
    }
    export class FullBlockBody extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            transactions?: dependency_2.co.topl.brambl.models.transaction.IoTransaction[];
            rewardTransaction?: dependency_2.co.topl.brambl.models.transaction.IoTransaction;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("transactions" in data && data.transactions != undefined) {
                    this.transactions = data.transactions;
                }
                if ("rewardTransaction" in data && data.rewardTransaction != undefined) {
                    this.rewardTransaction = data.rewardTransaction;
                }
            }
        }
        get transactions() {
            return pb_1.Message.getRepeatedWrapperField(this, dependency_2.co.topl.brambl.models.transaction.IoTransaction, 1) as dependency_2.co.topl.brambl.models.transaction.IoTransaction[];
        }
        set transactions(value: dependency_2.co.topl.brambl.models.transaction.IoTransaction[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get rewardTransaction() {
            return pb_1.Message.getWrapperField(this, dependency_2.co.topl.brambl.models.transaction.IoTransaction, 2) as dependency_2.co.topl.brambl.models.transaction.IoTransaction;
        }
        set rewardTransaction(value: dependency_2.co.topl.brambl.models.transaction.IoTransaction) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_rewardTransaction() {
            return pb_1.Message.getField(this, 2) != null;
        }
        static fromObject(data: {
            transactions?: ReturnType<typeof dependency_2.co.topl.brambl.models.transaction.IoTransaction.prototype.toObject>[];
            rewardTransaction?: ReturnType<typeof dependency_2.co.topl.brambl.models.transaction.IoTransaction.prototype.toObject>;
        }): FullBlockBody {
            const message = new FullBlockBody({});
            if (data.transactions != null) {
                message.transactions = data.transactions.map(item => dependency_2.co.topl.brambl.models.transaction.IoTransaction.fromObject(item));
            }
            if (data.rewardTransaction != null) {
                message.rewardTransaction = dependency_2.co.topl.brambl.models.transaction.IoTransaction.fromObject(data.rewardTransaction);
            }
            return message;
        }
        toObject() {
            const data: {
                transactions?: ReturnType<typeof dependency_2.co.topl.brambl.models.transaction.IoTransaction.prototype.toObject>[];
                rewardTransaction?: ReturnType<typeof dependency_2.co.topl.brambl.models.transaction.IoTransaction.prototype.toObject>;
            } = {};
            if (this.transactions != null) {
                data.transactions = this.transactions.map((item: dependency_2.co.topl.brambl.models.transaction.IoTransaction) => item.toObject());
            }
            if (this.rewardTransaction != null) {
                data.rewardTransaction = this.rewardTransaction.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.transactions.length)
                writer.writeRepeatedMessage(1, this.transactions, (item: dependency_2.co.topl.brambl.models.transaction.IoTransaction) => item.serialize(writer));
            if (this.has_rewardTransaction)
                writer.writeMessage(2, this.rewardTransaction, () => this.rewardTransaction.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FullBlockBody {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new FullBlockBody();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.transactions, () => pb_1.Message.addToRepeatedWrapperField(message, 1, dependency_2.co.topl.brambl.models.transaction.IoTransaction.deserialize(reader), dependency_2.co.topl.brambl.models.transaction.IoTransaction));
                        break;
                    case 2:
                        reader.readMessage(message.rewardTransaction, () => message.rewardTransaction = dependency_2.co.topl.brambl.models.transaction.IoTransaction.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): FullBlockBody {
            return FullBlockBody.deserialize(bytes);
        }
    }
    export class Block extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            header?: dependency_1.co.topl.consensus.models.BlockHeader;
            body?: BlockBody;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("header" in data && data.header != undefined) {
                    this.header = data.header;
                }
                if ("body" in data && data.body != undefined) {
                    this.body = data.body;
                }
            }
        }
        get header() {
            return pb_1.Message.getWrapperField(this, dependency_1.co.topl.consensus.models.BlockHeader, 1) as dependency_1.co.topl.consensus.models.BlockHeader;
        }
        set header(value: dependency_1.co.topl.consensus.models.BlockHeader) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_header() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get body() {
            return pb_1.Message.getWrapperField(this, BlockBody, 2) as BlockBody;
        }
        set body(value: BlockBody) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_body() {
            return pb_1.Message.getField(this, 2) != null;
        }
        static fromObject(data: {
            header?: ReturnType<typeof dependency_1.co.topl.consensus.models.BlockHeader.prototype.toObject>;
            body?: ReturnType<typeof BlockBody.prototype.toObject>;
        }): Block {
            const message = new Block({});
            if (data.header != null) {
                message.header = dependency_1.co.topl.consensus.models.BlockHeader.fromObject(data.header);
            }
            if (data.body != null) {
                message.body = BlockBody.fromObject(data.body);
            }
            return message;
        }
        toObject() {
            const data: {
                header?: ReturnType<typeof dependency_1.co.topl.consensus.models.BlockHeader.prototype.toObject>;
                body?: ReturnType<typeof BlockBody.prototype.toObject>;
            } = {};
            if (this.header != null) {
                data.header = this.header.toObject();
            }
            if (this.body != null) {
                data.body = this.body.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_header)
                writer.writeMessage(1, this.header, () => this.header.serialize(writer));
            if (this.has_body)
                writer.writeMessage(2, this.body, () => this.body.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Block {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Block();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.header, () => message.header = dependency_1.co.topl.consensus.models.BlockHeader.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.body, () => message.body = BlockBody.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Block {
            return Block.deserialize(bytes);
        }
    }
    export class FullBlock extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            header?: dependency_1.co.topl.consensus.models.BlockHeader;
            fullBody?: FullBlockBody;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("header" in data && data.header != undefined) {
                    this.header = data.header;
                }
                if ("fullBody" in data && data.fullBody != undefined) {
                    this.fullBody = data.fullBody;
                }
            }
        }
        get header() {
            return pb_1.Message.getWrapperField(this, dependency_1.co.topl.consensus.models.BlockHeader, 1) as dependency_1.co.topl.consensus.models.BlockHeader;
        }
        set header(value: dependency_1.co.topl.consensus.models.BlockHeader) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_header() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get fullBody() {
            return pb_1.Message.getWrapperField(this, FullBlockBody, 2) as FullBlockBody;
        }
        set fullBody(value: FullBlockBody) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_fullBody() {
            return pb_1.Message.getField(this, 2) != null;
        }
        static fromObject(data: {
            header?: ReturnType<typeof dependency_1.co.topl.consensus.models.BlockHeader.prototype.toObject>;
            fullBody?: ReturnType<typeof FullBlockBody.prototype.toObject>;
        }): FullBlock {
            const message = new FullBlock({});
            if (data.header != null) {
                message.header = dependency_1.co.topl.consensus.models.BlockHeader.fromObject(data.header);
            }
            if (data.fullBody != null) {
                message.fullBody = FullBlockBody.fromObject(data.fullBody);
            }
            return message;
        }
        toObject() {
            const data: {
                header?: ReturnType<typeof dependency_1.co.topl.consensus.models.BlockHeader.prototype.toObject>;
                fullBody?: ReturnType<typeof FullBlockBody.prototype.toObject>;
            } = {};
            if (this.header != null) {
                data.header = this.header.toObject();
            }
            if (this.fullBody != null) {
                data.fullBody = this.fullBody.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_header)
                writer.writeMessage(1, this.header, () => this.header.serialize(writer));
            if (this.has_fullBody)
                writer.writeMessage(2, this.fullBody, () => this.fullBody.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FullBlock {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new FullBlock();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.header, () => message.header = dependency_1.co.topl.consensus.models.BlockHeader.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.fullBody, () => message.fullBody = FullBlockBody.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): FullBlock {
            return FullBlock.deserialize(bytes);
        }
    }
}
