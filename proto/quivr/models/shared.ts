
/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.6.1
 * source: quivr/models/shared.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
export namespace quivr.models {
    export class Data extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            value?: Uint8Array;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
            }
        }
        get value() {
            return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
        }
        set value(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            value?: Uint8Array;
        }): Data {
            const message = new Data({});
            if (data.value != null) {
                message.value = data.value;
            }
            return message;
        }
        toObject() {
            const data: {
                value?: Uint8Array;
            } = {};
            if (this.value != null) {
                data.value = this.value;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.value.length)
                writer.writeBytes(1, this.value);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Data {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Data();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.value = reader.readBytes();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Data {
            return Data.deserialize(bytes);
        }
    }
    export class SmallData extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            value?: Uint8Array;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
            }
        }
        get value() {
            return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
        }
        set value(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            value?: Uint8Array;
        }): SmallData {
            const message = new SmallData({});
            if (data.value != null) {
                message.value = data.value;
            }
            return message;
        }
        toObject() {
            const data: {
                value?: Uint8Array;
            } = {};
            if (this.value != null) {
                data.value = this.value;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.value.length)
                writer.writeBytes(1, this.value);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SmallData {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SmallData();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.value = reader.readBytes();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SmallData {
            return SmallData.deserialize(bytes);
        }
    }
    export class Root extends pb_1.Message {
        #one_of_decls: number[][] = [[1, 2]];
        constructor(data?: any[] | ({} & (({
            root32?: Uint8Array;
            root64?: never;
        } | {
            root32?: never;
            root64?: Uint8Array;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("root32" in data && data.root32 != undefined) {
                    this.root32 = data.root32;
                }
                if ("root64" in data && data.root64 != undefined) {
                    this.root64 = data.root64;
                }
            }
        }
        get root32() {
            return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
        }
        set root32(value: Uint8Array) {
            pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
        }
        get has_root32() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get root64() {
            return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array(0)) as Uint8Array;
        }
        set root64(value: Uint8Array) {
            pb_1.Message.setOneofField(this, 2, this.#one_of_decls[0], value);
        }
        get has_root64() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get value() {
            const cases: {
                [index: number]: "none" | "root32" | "root64";
            } = {
                0: "none",
                1: "root32",
                2: "root64"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1, 2])];
        }
        static fromObject(data: {
            root32?: Uint8Array;
            root64?: Uint8Array;
        }): Root {
            const message = new Root({});
            if (data.root32 != null) {
                message.root32 = data.root32;
            }
            if (data.root64 != null) {
                message.root64 = data.root64;
            }
            return message;
        }
        toObject() {
            const data: {
                root32?: Uint8Array;
                root64?: Uint8Array;
            } = {};
            if (this.root32 != null) {
                data.root32 = this.root32;
            }
            if (this.root64 != null) {
                data.root64 = this.root64;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_root32)
                writer.writeBytes(1, this.root32);
            if (this.has_root64)
                writer.writeBytes(2, this.root64);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Root {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Root();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.root32 = reader.readBytes();
                        break;
                    case 2:
                        message.root64 = reader.readBytes();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Root {
            return Root.deserialize(bytes);
        }
    }
    export class Preimage extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            input?: Uint8Array;
            salt?: Uint8Array;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("input" in data && data.input != undefined) {
                    this.input = data.input;
                }
                if ("salt" in data && data.salt != undefined) {
                    this.salt = data.salt;
                }
            }
        }
        get input() {
            return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
        }
        set input(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        get salt() {
            return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array(0)) as Uint8Array;
        }
        set salt(value: Uint8Array) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            input?: Uint8Array;
            salt?: Uint8Array;
        }): Preimage {
            const message = new Preimage({});
            if (data.input != null) {
                message.input = data.input;
            }
            if (data.salt != null) {
                message.salt = data.salt;
            }
            return message;
        }
        toObject() {
            const data: {
                input?: Uint8Array;
                salt?: Uint8Array;
            } = {};
            if (this.input != null) {
                data.input = this.input;
            }
            if (this.salt != null) {
                data.salt = this.salt;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.input.length)
                writer.writeBytes(1, this.input);
            if (this.salt.length)
                writer.writeBytes(2, this.salt);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Preimage {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Preimage();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.input = reader.readBytes();
                        break;
                    case 2:
                        message.salt = reader.readBytes();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Preimage {
            return Preimage.deserialize(bytes);
        }
    }
    export class Digest extends pb_1.Message {
        #one_of_decls: number[][] = [[1, 2]];
        constructor(data?: any[] | ({} & (({
            digest32?: Digest.Digest32;
            digest64?: never;
        } | {
            digest32?: never;
            digest64?: Digest.Digest64;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("digest32" in data && data.digest32 != undefined) {
                    this.digest32 = data.digest32;
                }
                if ("digest64" in data && data.digest64 != undefined) {
                    this.digest64 = data.digest64;
                }
            }
        }
        get digest32() {
            return pb_1.Message.getWrapperField(this, Digest.Digest32, 1) as Digest.Digest32;
        }
        set digest32(value: Digest.Digest32) {
            pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
        }
        get has_digest32() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get digest64() {
            return pb_1.Message.getWrapperField(this, Digest.Digest64, 2) as Digest.Digest64;
        }
        set digest64(value: Digest.Digest64) {
            pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
        }
        get has_digest64() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get value() {
            const cases: {
                [index: number]: "none" | "digest32" | "digest64";
            } = {
                0: "none",
                1: "digest32",
                2: "digest64"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1, 2])];
        }
        static fromObject(data: {
            digest32?: ReturnType<typeof Digest.Digest32.prototype.toObject>;
            digest64?: ReturnType<typeof Digest.Digest64.prototype.toObject>;
        }): Digest {
            const message = new Digest({});
            if (data.digest32 != null) {
                message.digest32 = Digest.Digest32.fromObject(data.digest32);
            }
            if (data.digest64 != null) {
                message.digest64 = Digest.Digest64.fromObject(data.digest64);
            }
            return message;
        }
        toObject() {
            const data: {
                digest32?: ReturnType<typeof Digest.Digest32.prototype.toObject>;
                digest64?: ReturnType<typeof Digest.Digest64.prototype.toObject>;
            } = {};
            if (this.digest32 != null) {
                data.digest32 = this.digest32.toObject();
            }
            if (this.digest64 != null) {
                data.digest64 = this.digest64.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_digest32)
                writer.writeMessage(1, this.digest32, () => this.digest32.serialize(writer));
            if (this.has_digest64)
                writer.writeMessage(2, this.digest64, () => this.digest64.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Digest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Digest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.digest32, () => message.digest32 = Digest.Digest32.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.digest64, () => message.digest64 = Digest.Digest64.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Digest {
            return Digest.deserialize(bytes);
        }
    }
    export namespace Digest {
        export class Digest32 extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                value?: Uint8Array;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("value" in data && data.value != undefined) {
                        this.value = data.value;
                    }
                }
            }
            get value() {
                return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
            }
            set value(value: Uint8Array) {
                pb_1.Message.setField(this, 1, value);
            }
            static fromObject(data: {
                value?: Uint8Array;
            }): Digest32 {
                const message = new Digest32({});
                if (data.value != null) {
                    message.value = data.value;
                }
                return message;
            }
            toObject() {
                const data: {
                    value?: Uint8Array;
                } = {};
                if (this.value != null) {
                    data.value = this.value;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.value.length)
                    writer.writeBytes(1, this.value);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Digest32 {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Digest32();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.value = reader.readBytes();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Digest32 {
                return Digest32.deserialize(bytes);
            }
        }
        export class Digest64 extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                value?: Uint8Array;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("value" in data && data.value != undefined) {
                        this.value = data.value;
                    }
                }
            }
            get value() {
                return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
            }
            set value(value: Uint8Array) {
                pb_1.Message.setField(this, 1, value);
            }
            static fromObject(data: {
                value?: Uint8Array;
            }): Digest64 {
                const message = new Digest64({});
                if (data.value != null) {
                    message.value = data.value;
                }
                return message;
            }
            toObject() {
                const data: {
                    value?: Uint8Array;
                } = {};
                if (this.value != null) {
                    data.value = this.value;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.value.length)
                    writer.writeBytes(1, this.value);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Digest64 {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Digest64();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.value = reader.readBytes();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Digest64 {
                return Digest64.deserialize(bytes);
            }
        }
    }
    export class DigestVerification extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            digest?: Digest;
            preimage?: Preimage;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("digest" in data && data.digest != undefined) {
                    this.digest = data.digest;
                }
                if ("preimage" in data && data.preimage != undefined) {
                    this.preimage = data.preimage;
                }
            }
        }
        get digest() {
            return pb_1.Message.getWrapperField(this, Digest, 1) as Digest;
        }
        set digest(value: Digest) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_digest() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get preimage() {
            return pb_1.Message.getWrapperField(this, Preimage, 2) as Preimage;
        }
        set preimage(value: Preimage) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_preimage() {
            return pb_1.Message.getField(this, 2) != null;
        }
        static fromObject(data: {
            digest?: ReturnType<typeof Digest.prototype.toObject>;
            preimage?: ReturnType<typeof Preimage.prototype.toObject>;
        }): DigestVerification {
            const message = new DigestVerification({});
            if (data.digest != null) {
                message.digest = Digest.fromObject(data.digest);
            }
            if (data.preimage != null) {
                message.preimage = Preimage.fromObject(data.preimage);
            }
            return message;
        }
        toObject() {
            const data: {
                digest?: ReturnType<typeof Digest.prototype.toObject>;
                preimage?: ReturnType<typeof Preimage.prototype.toObject>;
            } = {};
            if (this.digest != null) {
                data.digest = this.digest.toObject();
            }
            if (this.preimage != null) {
                data.preimage = this.preimage.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_digest)
                writer.writeMessage(1, this.digest, () => this.digest.serialize(writer));
            if (this.has_preimage)
                writer.writeMessage(2, this.preimage, () => this.preimage.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DigestVerification {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new DigestVerification();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.digest, () => message.digest = Digest.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.preimage, () => message.preimage = Preimage.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): DigestVerification {
            return DigestVerification.deserialize(bytes);
        }
    }
    export class VerificationKey extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            value?: Uint8Array;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
            }
        }
        get value() {
            return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
        }
        set value(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            value?: Uint8Array;
        }): VerificationKey {
            const message = new VerificationKey({});
            if (data.value != null) {
                message.value = data.value;
            }
            return message;
        }
        toObject() {
            const data: {
                value?: Uint8Array;
            } = {};
            if (this.value != null) {
                data.value = this.value;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.value.length)
                writer.writeBytes(1, this.value);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): VerificationKey {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new VerificationKey();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.value = reader.readBytes();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): VerificationKey {
            return VerificationKey.deserialize(bytes);
        }
    }
    export class SigningKey extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            value?: Uint8Array;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
            }
        }
        get value() {
            return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
        }
        set value(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            value?: Uint8Array;
        }): SigningKey {
            const message = new SigningKey({});
            if (data.value != null) {
                message.value = data.value;
            }
            return message;
        }
        toObject() {
            const data: {
                value?: Uint8Array;
            } = {};
            if (this.value != null) {
                data.value = this.value;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.value.length)
                writer.writeBytes(1, this.value);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SigningKey {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SigningKey();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.value = reader.readBytes();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SigningKey {
            return SigningKey.deserialize(bytes);
        }
    }
    export class KeyPair extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            vk?: VerificationKey;
            sk?: SigningKey;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("vk" in data && data.vk != undefined) {
                    this.vk = data.vk;
                }
                if ("sk" in data && data.sk != undefined) {
                    this.sk = data.sk;
                }
            }
        }
        get vk() {
            return pb_1.Message.getWrapperField(this, VerificationKey, 1) as VerificationKey;
        }
        set vk(value: VerificationKey) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_vk() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get sk() {
            return pb_1.Message.getWrapperField(this, SigningKey, 2) as SigningKey;
        }
        set sk(value: SigningKey) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_sk() {
            return pb_1.Message.getField(this, 2) != null;
        }
        static fromObject(data: {
            vk?: ReturnType<typeof VerificationKey.prototype.toObject>;
            sk?: ReturnType<typeof SigningKey.prototype.toObject>;
        }): KeyPair {
            const message = new KeyPair({});
            if (data.vk != null) {
                message.vk = VerificationKey.fromObject(data.vk);
            }
            if (data.sk != null) {
                message.sk = SigningKey.fromObject(data.sk);
            }
            return message;
        }
        toObject() {
            const data: {
                vk?: ReturnType<typeof VerificationKey.prototype.toObject>;
                sk?: ReturnType<typeof SigningKey.prototype.toObject>;
            } = {};
            if (this.vk != null) {
                data.vk = this.vk.toObject();
            }
            if (this.sk != null) {
                data.sk = this.sk.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_vk)
                writer.writeMessage(1, this.vk, () => this.vk.serialize(writer));
            if (this.has_sk)
                writer.writeMessage(2, this.sk, () => this.sk.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): KeyPair {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new KeyPair();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.vk, () => message.vk = VerificationKey.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.sk, () => message.sk = SigningKey.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): KeyPair {
            return KeyPair.deserialize(bytes);
        }
    }
    export class Message extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            value?: Uint8Array;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
            }
        }
        get value() {
            return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
        }
        set value(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            value?: Uint8Array;
        }): Message {
            const message = new Message({});
            if (data.value != null) {
                message.value = data.value;
            }
            return message;
        }
        toObject() {
            const data: {
                value?: Uint8Array;
            } = {};
            if (this.value != null) {
                data.value = this.value;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.value.length)
                writer.writeBytes(1, this.value);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Message {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Message();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.value = reader.readBytes();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Message {
            return Message.deserialize(bytes);
        }
    }
    export class Witness extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            value?: Uint8Array;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
            }
        }
        get value() {
            return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
        }
        set value(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            value?: Uint8Array;
        }): Witness {
            const message = new Witness({});
            if (data.value != null) {
                message.value = data.value;
            }
            return message;
        }
        toObject() {
            const data: {
                value?: Uint8Array;
            } = {};
            if (this.value != null) {
                data.value = this.value;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.value.length)
                writer.writeBytes(1, this.value);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Witness {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Witness();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.value = reader.readBytes();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Witness {
            return Witness.deserialize(bytes);
        }
    }
    export class SignatureVerification extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            verificationKey?: VerificationKey;
            signature?: Witness;
            message?: Message;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("verificationKey" in data && data.verificationKey != undefined) {
                    this.verificationKey = data.verificationKey;
                }
                if ("signature" in data && data.signature != undefined) {
                    this.signature = data.signature;
                }
                if ("message" in data && data.message != undefined) {
                    this.message = data.message;
                }
            }
        }
        get verificationKey() {
            return pb_1.Message.getWrapperField(this, VerificationKey, 1) as VerificationKey;
        }
        set verificationKey(value: VerificationKey) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_verificationKey() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get signature() {
            return pb_1.Message.getWrapperField(this, Witness, 2) as Witness;
        }
        set signature(value: Witness) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_signature() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get message() {
            return pb_1.Message.getWrapperField(this, Message, 3) as Message;
        }
        set message(value: Message) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_message() {
            return pb_1.Message.getField(this, 3) != null;
        }
        static fromObject(data: {
            verificationKey?: ReturnType<typeof VerificationKey.prototype.toObject>;
            signature?: ReturnType<typeof Witness.prototype.toObject>;
            message?: ReturnType<typeof Message.prototype.toObject>;
        }): SignatureVerification {
            const message = new SignatureVerification({});
            if (data.verificationKey != null) {
                message.verificationKey = VerificationKey.fromObject(data.verificationKey);
            }
            if (data.signature != null) {
                message.signature = Witness.fromObject(data.signature);
            }
            if (data.message != null) {
                message.message = Message.fromObject(data.message);
            }
            return message;
        }
        toObject() {
            const data: {
                verificationKey?: ReturnType<typeof VerificationKey.prototype.toObject>;
                signature?: ReturnType<typeof Witness.prototype.toObject>;
                message?: ReturnType<typeof Message.prototype.toObject>;
            } = {};
            if (this.verificationKey != null) {
                data.verificationKey = this.verificationKey.toObject();
            }
            if (this.signature != null) {
                data.signature = this.signature.toObject();
            }
            if (this.message != null) {
                data.message = this.message.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_verificationKey)
                writer.writeMessage(1, this.verificationKey, () => this.verificationKey.serialize(writer));
            if (this.has_signature)
                writer.writeMessage(2, this.signature, () => this.signature.serialize(writer));
            if (this.has_message)
                writer.writeMessage(3, this.message, () => this.message.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SignatureVerification {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SignatureVerification();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.verificationKey, () => message.verificationKey = VerificationKey.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.signature, () => message.signature = Witness.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.message, () => message.message = Message.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SignatureVerification {
            return SignatureVerification.deserialize(bytes);
        }
    }
    export class SignableBytes extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            value?: Uint8Array;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
            }
        }
        get value() {
            return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
        }
        set value(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            value?: Uint8Array;
        }): SignableBytes {
            const message = new SignableBytes({});
            if (data.value != null) {
                message.value = data.value;
            }
            return message;
        }
        toObject() {
            const data: {
                value?: Uint8Array;
            } = {};
            if (this.value != null) {
                data.value = this.value;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.value.length)
                writer.writeBytes(1, this.value);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SignableBytes {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SignableBytes();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.value = reader.readBytes();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SignableBytes {
            return SignableBytes.deserialize(bytes);
        }
    }
    export class TxBind extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            value?: Uint8Array;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
            }
        }
        get value() {
            return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array(0)) as Uint8Array;
        }
        set value(value: Uint8Array) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            value?: Uint8Array;
        }): TxBind {
            const message = new TxBind({});
            if (data.value != null) {
                message.value = data.value;
            }
            return message;
        }
        toObject() {
            const data: {
                value?: Uint8Array;
            } = {};
            if (this.value != null) {
                data.value = this.value;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.value.length)
                writer.writeBytes(2, this.value);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TxBind {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TxBind();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 2:
                        message.value = reader.readBytes();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): TxBind {
            return TxBind.deserialize(bytes);
        }
    }
    export class Int128 extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            value?: Uint8Array;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
            }
        }
        get value() {
            return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
        }
        set value(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            value?: Uint8Array;
        }): Int128 {
            const message = new Int128({});
            if (data.value != null) {
                message.value = data.value;
            }
            return message;
        }
        toObject() {
            const data: {
                value?: Uint8Array;
            } = {};
            if (this.value != null) {
                data.value = this.value;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.value.length)
                writer.writeBytes(1, this.value);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Int128 {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Int128();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.value = reader.readBytes();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Int128 {
            return Int128.deserialize(bytes);
        }
    }
}
