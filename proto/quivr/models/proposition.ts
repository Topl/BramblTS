/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.6.1
 * source: quivr/models/proposition.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./shared";
import * as dependency_2 from "./../../validate/validate";
import * as pb_1 from "google-protobuf";
export namespace quivr.models {
    export class Proposition extends pb_1.Message {
        #one_of_decls: number[][] = [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]];
        constructor(data?: any[] | ({} & (({
            locked?: Proposition.Locked;
            digest?: never;
            digitalSignature?: never;
            heightRange?: never;
            tickRange?: never;
            exactMatch?: never;
            lessThan?: never;
            greaterThan?: never;
            equalTo?: never;
            threshold?: never;
            not?: never;
            and?: never;
            or?: never;
        } | {
            locked?: never;
            digest?: Proposition.Digest;
            digitalSignature?: never;
            heightRange?: never;
            tickRange?: never;
            exactMatch?: never;
            lessThan?: never;
            greaterThan?: never;
            equalTo?: never;
            threshold?: never;
            not?: never;
            and?: never;
            or?: never;
        } | {
            locked?: never;
            digest?: never;
            digitalSignature?: Proposition.DigitalSignature;
            heightRange?: never;
            tickRange?: never;
            exactMatch?: never;
            lessThan?: never;
            greaterThan?: never;
            equalTo?: never;
            threshold?: never;
            not?: never;
            and?: never;
            or?: never;
        } | {
            locked?: never;
            digest?: never;
            digitalSignature?: never;
            heightRange?: Proposition.HeightRange;
            tickRange?: never;
            exactMatch?: never;
            lessThan?: never;
            greaterThan?: never;
            equalTo?: never;
            threshold?: never;
            not?: never;
            and?: never;
            or?: never;
        } | {
            locked?: never;
            digest?: never;
            digitalSignature?: never;
            heightRange?: never;
            tickRange?: Proposition.TickRange;
            exactMatch?: never;
            lessThan?: never;
            greaterThan?: never;
            equalTo?: never;
            threshold?: never;
            not?: never;
            and?: never;
            or?: never;
        } | {
            locked?: never;
            digest?: never;
            digitalSignature?: never;
            heightRange?: never;
            tickRange?: never;
            exactMatch?: Proposition.ExactMatch;
            lessThan?: never;
            greaterThan?: never;
            equalTo?: never;
            threshold?: never;
            not?: never;
            and?: never;
            or?: never;
        } | {
            locked?: never;
            digest?: never;
            digitalSignature?: never;
            heightRange?: never;
            tickRange?: never;
            exactMatch?: never;
            lessThan?: Proposition.LessThan;
            greaterThan?: never;
            equalTo?: never;
            threshold?: never;
            not?: never;
            and?: never;
            or?: never;
        } | {
            locked?: never;
            digest?: never;
            digitalSignature?: never;
            heightRange?: never;
            tickRange?: never;
            exactMatch?: never;
            lessThan?: never;
            greaterThan?: Proposition.GreaterThan;
            equalTo?: never;
            threshold?: never;
            not?: never;
            and?: never;
            or?: never;
        } | {
            locked?: never;
            digest?: never;
            digitalSignature?: never;
            heightRange?: never;
            tickRange?: never;
            exactMatch?: never;
            lessThan?: never;
            greaterThan?: never;
            equalTo?: Proposition.EqualTo;
            threshold?: never;
            not?: never;
            and?: never;
            or?: never;
        } | {
            locked?: never;
            digest?: never;
            digitalSignature?: never;
            heightRange?: never;
            tickRange?: never;
            exactMatch?: never;
            lessThan?: never;
            greaterThan?: never;
            equalTo?: never;
            threshold?: Proposition.Threshold;
            not?: never;
            and?: never;
            or?: never;
        } | {
            locked?: never;
            digest?: never;
            digitalSignature?: never;
            heightRange?: never;
            tickRange?: never;
            exactMatch?: never;
            lessThan?: never;
            greaterThan?: never;
            equalTo?: never;
            threshold?: never;
            not?: Proposition.Not;
            and?: never;
            or?: never;
        } | {
            locked?: never;
            digest?: never;
            digitalSignature?: never;
            heightRange?: never;
            tickRange?: never;
            exactMatch?: never;
            lessThan?: never;
            greaterThan?: never;
            equalTo?: never;
            threshold?: never;
            not?: never;
            and?: Proposition.And;
            or?: never;
        } | {
            locked?: never;
            digest?: never;
            digitalSignature?: never;
            heightRange?: never;
            tickRange?: never;
            exactMatch?: never;
            lessThan?: never;
            greaterThan?: never;
            equalTo?: never;
            threshold?: never;
            not?: never;
            and?: never;
            or?: Proposition.Or;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("locked" in data && data.locked != undefined) {
                    this.locked = data.locked;
                }
                if ("digest" in data && data.digest != undefined) {
                    this.digest = data.digest;
                }
                if ("digitalSignature" in data && data.digitalSignature != undefined) {
                    this.digitalSignature = data.digitalSignature;
                }
                if ("heightRange" in data && data.heightRange != undefined) {
                    this.heightRange = data.heightRange;
                }
                if ("tickRange" in data && data.tickRange != undefined) {
                    this.tickRange = data.tickRange;
                }
                if ("exactMatch" in data && data.exactMatch != undefined) {
                    this.exactMatch = data.exactMatch;
                }
                if ("lessThan" in data && data.lessThan != undefined) {
                    this.lessThan = data.lessThan;
                }
                if ("greaterThan" in data && data.greaterThan != undefined) {
                    this.greaterThan = data.greaterThan;
                }
                if ("equalTo" in data && data.equalTo != undefined) {
                    this.equalTo = data.equalTo;
                }
                if ("threshold" in data && data.threshold != undefined) {
                    this.threshold = data.threshold;
                }
                if ("not" in data && data.not != undefined) {
                    this.not = data.not;
                }
                if ("and" in data && data.and != undefined) {
                    this.and = data.and;
                }
                if ("or" in data && data.or != undefined) {
                    this.or = data.or;
                }
            }
        }
        get locked() {
            return pb_1.Message.getWrapperField(this, Proposition.Locked, 1) as Proposition.Locked;
        }
        set locked(value: Proposition.Locked) {
            pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
        }
        get has_locked() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get digest() {
            return pb_1.Message.getWrapperField(this, Proposition.Digest, 2) as Proposition.Digest;
        }
        set digest(value: Proposition.Digest) {
            pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
        }
        get has_digest() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get digitalSignature() {
            return pb_1.Message.getWrapperField(this, Proposition.DigitalSignature, 3) as Proposition.DigitalSignature;
        }
        set digitalSignature(value: Proposition.DigitalSignature) {
            pb_1.Message.setOneofWrapperField(this, 3, this.#one_of_decls[0], value);
        }
        get has_digitalSignature() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get heightRange() {
            return pb_1.Message.getWrapperField(this, Proposition.HeightRange, 4) as Proposition.HeightRange;
        }
        set heightRange(value: Proposition.HeightRange) {
            pb_1.Message.setOneofWrapperField(this, 4, this.#one_of_decls[0], value);
        }
        get has_heightRange() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get tickRange() {
            return pb_1.Message.getWrapperField(this, Proposition.TickRange, 5) as Proposition.TickRange;
        }
        set tickRange(value: Proposition.TickRange) {
            pb_1.Message.setOneofWrapperField(this, 5, this.#one_of_decls[0], value);
        }
        get has_tickRange() {
            return pb_1.Message.getField(this, 5) != null;
        }
        get exactMatch() {
            return pb_1.Message.getWrapperField(this, Proposition.ExactMatch, 6) as Proposition.ExactMatch;
        }
        set exactMatch(value: Proposition.ExactMatch) {
            pb_1.Message.setOneofWrapperField(this, 6, this.#one_of_decls[0], value);
        }
        get has_exactMatch() {
            return pb_1.Message.getField(this, 6) != null;
        }
        get lessThan() {
            return pb_1.Message.getWrapperField(this, Proposition.LessThan, 7) as Proposition.LessThan;
        }
        set lessThan(value: Proposition.LessThan) {
            pb_1.Message.setOneofWrapperField(this, 7, this.#one_of_decls[0], value);
        }
        get has_lessThan() {
            return pb_1.Message.getField(this, 7) != null;
        }
        get greaterThan() {
            return pb_1.Message.getWrapperField(this, Proposition.GreaterThan, 8) as Proposition.GreaterThan;
        }
        set greaterThan(value: Proposition.GreaterThan) {
            pb_1.Message.setOneofWrapperField(this, 8, this.#one_of_decls[0], value);
        }
        get has_greaterThan() {
            return pb_1.Message.getField(this, 8) != null;
        }
        get equalTo() {
            return pb_1.Message.getWrapperField(this, Proposition.EqualTo, 9) as Proposition.EqualTo;
        }
        set equalTo(value: Proposition.EqualTo) {
            pb_1.Message.setOneofWrapperField(this, 9, this.#one_of_decls[0], value);
        }
        get has_equalTo() {
            return pb_1.Message.getField(this, 9) != null;
        }
        get threshold() {
            return pb_1.Message.getWrapperField(this, Proposition.Threshold, 10) as Proposition.Threshold;
        }
        set threshold(value: Proposition.Threshold) {
            pb_1.Message.setOneofWrapperField(this, 10, this.#one_of_decls[0], value);
        }
        get has_threshold() {
            return pb_1.Message.getField(this, 10) != null;
        }
        get not() {
            return pb_1.Message.getWrapperField(this, Proposition.Not, 11) as Proposition.Not;
        }
        set not(value: Proposition.Not) {
            pb_1.Message.setOneofWrapperField(this, 11, this.#one_of_decls[0], value);
        }
        get has_not() {
            return pb_1.Message.getField(this, 11) != null;
        }
        get and() {
            return pb_1.Message.getWrapperField(this, Proposition.And, 12) as Proposition.And;
        }
        set and(value: Proposition.And) {
            pb_1.Message.setOneofWrapperField(this, 12, this.#one_of_decls[0], value);
        }
        get has_and() {
            return pb_1.Message.getField(this, 12) != null;
        }
        get or() {
            return pb_1.Message.getWrapperField(this, Proposition.Or, 13) as Proposition.Or;
        }
        set or(value: Proposition.Or) {
            pb_1.Message.setOneofWrapperField(this, 13, this.#one_of_decls[0], value);
        }
        get has_or() {
            return pb_1.Message.getField(this, 13) != null;
        }
        get value() {
            const cases: {
                [index: number]: "none" | "locked" | "digest" | "digitalSignature" | "heightRange" | "tickRange" | "exactMatch" | "lessThan" | "greaterThan" | "equalTo" | "threshold" | "not" | "and" | "or";
            } = {
                0: "none",
                1: "locked",
                2: "digest",
                3: "digitalSignature",
                4: "heightRange",
                5: "tickRange",
                6: "exactMatch",
                7: "lessThan",
                8: "greaterThan",
                9: "equalTo",
                10: "threshold",
                11: "not",
                12: "and",
                13: "or"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13])];
        }
        static fromObject(data: {
            locked?: ReturnType<typeof Proposition.Locked.prototype.toObject>;
            digest?: ReturnType<typeof Proposition.Digest.prototype.toObject>;
            digitalSignature?: ReturnType<typeof Proposition.DigitalSignature.prototype.toObject>;
            heightRange?: ReturnType<typeof Proposition.HeightRange.prototype.toObject>;
            tickRange?: ReturnType<typeof Proposition.TickRange.prototype.toObject>;
            exactMatch?: ReturnType<typeof Proposition.ExactMatch.prototype.toObject>;
            lessThan?: ReturnType<typeof Proposition.LessThan.prototype.toObject>;
            greaterThan?: ReturnType<typeof Proposition.GreaterThan.prototype.toObject>;
            equalTo?: ReturnType<typeof Proposition.EqualTo.prototype.toObject>;
            threshold?: ReturnType<typeof Proposition.Threshold.prototype.toObject>;
            not?: ReturnType<typeof Proposition.Not.prototype.toObject>;
            and?: ReturnType<typeof Proposition.And.prototype.toObject>;
            or?: ReturnType<typeof Proposition.Or.prototype.toObject>;
        }): Proposition {
            const message = new Proposition({});
            if (data.locked != null) {
                message.locked = Proposition.Locked.fromObject(data.locked);
            }
            if (data.digest != null) {
                message.digest = Proposition.Digest.fromObject(data.digest);
            }
            if (data.digitalSignature != null) {
                message.digitalSignature = Proposition.DigitalSignature.fromObject(data.digitalSignature);
            }
            if (data.heightRange != null) {
                message.heightRange = Proposition.HeightRange.fromObject(data.heightRange);
            }
            if (data.tickRange != null) {
                message.tickRange = Proposition.TickRange.fromObject(data.tickRange);
            }
            if (data.exactMatch != null) {
                message.exactMatch = Proposition.ExactMatch.fromObject(data.exactMatch);
            }
            if (data.lessThan != null) {
                message.lessThan = Proposition.LessThan.fromObject(data.lessThan);
            }
            if (data.greaterThan != null) {
                message.greaterThan = Proposition.GreaterThan.fromObject(data.greaterThan);
            }
            if (data.equalTo != null) {
                message.equalTo = Proposition.EqualTo.fromObject(data.equalTo);
            }
            if (data.threshold != null) {
                message.threshold = Proposition.Threshold.fromObject(data.threshold);
            }
            if (data.not != null) {
                message.not = Proposition.Not.fromObject(data.not);
            }
            if (data.and != null) {
                message.and = Proposition.And.fromObject(data.and);
            }
            if (data.or != null) {
                message.or = Proposition.Or.fromObject(data.or);
            }
            return message;
        }
        toObject() {
            const data: {
                locked?: ReturnType<typeof Proposition.Locked.prototype.toObject>;
                digest?: ReturnType<typeof Proposition.Digest.prototype.toObject>;
                digitalSignature?: ReturnType<typeof Proposition.DigitalSignature.prototype.toObject>;
                heightRange?: ReturnType<typeof Proposition.HeightRange.prototype.toObject>;
                tickRange?: ReturnType<typeof Proposition.TickRange.prototype.toObject>;
                exactMatch?: ReturnType<typeof Proposition.ExactMatch.prototype.toObject>;
                lessThan?: ReturnType<typeof Proposition.LessThan.prototype.toObject>;
                greaterThan?: ReturnType<typeof Proposition.GreaterThan.prototype.toObject>;
                equalTo?: ReturnType<typeof Proposition.EqualTo.prototype.toObject>;
                threshold?: ReturnType<typeof Proposition.Threshold.prototype.toObject>;
                not?: ReturnType<typeof Proposition.Not.prototype.toObject>;
                and?: ReturnType<typeof Proposition.And.prototype.toObject>;
                or?: ReturnType<typeof Proposition.Or.prototype.toObject>;
            } = {};
            if (this.locked != null) {
                data.locked = this.locked.toObject();
            }
            if (this.digest != null) {
                data.digest = this.digest.toObject();
            }
            if (this.digitalSignature != null) {
                data.digitalSignature = this.digitalSignature.toObject();
            }
            if (this.heightRange != null) {
                data.heightRange = this.heightRange.toObject();
            }
            if (this.tickRange != null) {
                data.tickRange = this.tickRange.toObject();
            }
            if (this.exactMatch != null) {
                data.exactMatch = this.exactMatch.toObject();
            }
            if (this.lessThan != null) {
                data.lessThan = this.lessThan.toObject();
            }
            if (this.greaterThan != null) {
                data.greaterThan = this.greaterThan.toObject();
            }
            if (this.equalTo != null) {
                data.equalTo = this.equalTo.toObject();
            }
            if (this.threshold != null) {
                data.threshold = this.threshold.toObject();
            }
            if (this.not != null) {
                data.not = this.not.toObject();
            }
            if (this.and != null) {
                data.and = this.and.toObject();
            }
            if (this.or != null) {
                data.or = this.or.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_locked)
                writer.writeMessage(1, this.locked, () => this.locked.serialize(writer));
            if (this.has_digest)
                writer.writeMessage(2, this.digest, () => this.digest.serialize(writer));
            if (this.has_digitalSignature)
                writer.writeMessage(3, this.digitalSignature, () => this.digitalSignature.serialize(writer));
            if (this.has_heightRange)
                writer.writeMessage(4, this.heightRange, () => this.heightRange.serialize(writer));
            if (this.has_tickRange)
                writer.writeMessage(5, this.tickRange, () => this.tickRange.serialize(writer));
            if (this.has_exactMatch)
                writer.writeMessage(6, this.exactMatch, () => this.exactMatch.serialize(writer));
            if (this.has_lessThan)
                writer.writeMessage(7, this.lessThan, () => this.lessThan.serialize(writer));
            if (this.has_greaterThan)
                writer.writeMessage(8, this.greaterThan, () => this.greaterThan.serialize(writer));
            if (this.has_equalTo)
                writer.writeMessage(9, this.equalTo, () => this.equalTo.serialize(writer));
            if (this.has_threshold)
                writer.writeMessage(10, this.threshold, () => this.threshold.serialize(writer));
            if (this.has_not)
                writer.writeMessage(11, this.not, () => this.not.serialize(writer));
            if (this.has_and)
                writer.writeMessage(12, this.and, () => this.and.serialize(writer));
            if (this.has_or)
                writer.writeMessage(13, this.or, () => this.or.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Proposition {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Proposition();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.locked, () => message.locked = Proposition.Locked.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.digest, () => message.digest = Proposition.Digest.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.digitalSignature, () => message.digitalSignature = Proposition.DigitalSignature.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.heightRange, () => message.heightRange = Proposition.HeightRange.deserialize(reader));
                        break;
                    case 5:
                        reader.readMessage(message.tickRange, () => message.tickRange = Proposition.TickRange.deserialize(reader));
                        break;
                    case 6:
                        reader.readMessage(message.exactMatch, () => message.exactMatch = Proposition.ExactMatch.deserialize(reader));
                        break;
                    case 7:
                        reader.readMessage(message.lessThan, () => message.lessThan = Proposition.LessThan.deserialize(reader));
                        break;
                    case 8:
                        reader.readMessage(message.greaterThan, () => message.greaterThan = Proposition.GreaterThan.deserialize(reader));
                        break;
                    case 9:
                        reader.readMessage(message.equalTo, () => message.equalTo = Proposition.EqualTo.deserialize(reader));
                        break;
                    case 10:
                        reader.readMessage(message.threshold, () => message.threshold = Proposition.Threshold.deserialize(reader));
                        break;
                    case 11:
                        reader.readMessage(message.not, () => message.not = Proposition.Not.deserialize(reader));
                        break;
                    case 12:
                        reader.readMessage(message.and, () => message.and = Proposition.And.deserialize(reader));
                        break;
                    case 13:
                        reader.readMessage(message.or, () => message.or = Proposition.Or.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Proposition {
            return Proposition.deserialize(bytes);
        }
    }
    export namespace Proposition {
        export class Locked extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                data?: dependency_1.quivr.models.Data;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("data" in data && data.data != undefined) {
                        this.data = data.data;
                    }
                }
            }
            get data() {
                return pb_1.Message.getWrapperField(this, dependency_1.quivr.models.Data, 1) as dependency_1.quivr.models.Data;
            }
            set data(value: dependency_1.quivr.models.Data) {
                pb_1.Message.setWrapperField(this, 1, value);
            }
            get has_data() {
                return pb_1.Message.getField(this, 1) != null;
            }
            static fromObject(data: {
                data?: ReturnType<typeof dependency_1.quivr.models.Data.prototype.toObject>;
            }): Locked {
                const message = new Locked({});
                if (data.data != null) {
                    message.data = dependency_1.quivr.models.Data.fromObject(data.data);
                }
                return message;
            }
            toObject() {
                const data: {
                    data?: ReturnType<typeof dependency_1.quivr.models.Data.prototype.toObject>;
                } = {};
                if (this.data != null) {
                    data.data = this.data.toObject();
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.has_data)
                    writer.writeMessage(1, this.data, () => this.data.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Locked {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Locked();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.data, () => message.data = dependency_1.quivr.models.Data.deserialize(reader));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Locked {
                return Locked.deserialize(bytes);
            }
        }
        export class Digest extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                routine?: string;
                digest?: dependency_1.quivr.models.Digest;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("routine" in data && data.routine != undefined) {
                        this.routine = data.routine;
                    }
                    if ("digest" in data && data.digest != undefined) {
                        this.digest = data.digest;
                    }
                }
            }
            get routine() {
                return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
            }
            set routine(value: string) {
                pb_1.Message.setField(this, 1, value);
            }
            get digest() {
                return pb_1.Message.getWrapperField(this, dependency_1.quivr.models.Digest, 2) as dependency_1.quivr.models.Digest;
            }
            set digest(value: dependency_1.quivr.models.Digest) {
                pb_1.Message.setWrapperField(this, 2, value);
            }
            get has_digest() {
                return pb_1.Message.getField(this, 2) != null;
            }
            static fromObject(data: {
                routine?: string;
                digest?: ReturnType<typeof dependency_1.quivr.models.Digest.prototype.toObject>;
            }): Digest {
                const message = new Digest({});
                if (data.routine != null) {
                    message.routine = data.routine;
                }
                if (data.digest != null) {
                    message.digest = dependency_1.quivr.models.Digest.fromObject(data.digest);
                }
                return message;
            }
            toObject() {
                const data: {
                    routine?: string;
                    digest?: ReturnType<typeof dependency_1.quivr.models.Digest.prototype.toObject>;
                } = {};
                if (this.routine != null) {
                    data.routine = this.routine;
                }
                if (this.digest != null) {
                    data.digest = this.digest.toObject();
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.routine.length)
                    writer.writeString(1, this.routine);
                if (this.has_digest)
                    writer.writeMessage(2, this.digest, () => this.digest.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Digest {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Digest();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.routine = reader.readString();
                            break;
                        case 2:
                            reader.readMessage(message.digest, () => message.digest = dependency_1.quivr.models.Digest.deserialize(reader));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Digest {
                return Digest.deserialize(bytes);
            }
        }
        export class DigitalSignature extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                routine?: string;
                verificationKey?: dependency_1.quivr.models.VerificationKey;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("routine" in data && data.routine != undefined) {
                        this.routine = data.routine;
                    }
                    if ("verificationKey" in data && data.verificationKey != undefined) {
                        this.verificationKey = data.verificationKey;
                    }
                }
            }
            get routine() {
                return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
            }
            set routine(value: string) {
                pb_1.Message.setField(this, 1, value);
            }
            get verificationKey() {
                return pb_1.Message.getWrapperField(this, dependency_1.quivr.models.VerificationKey, 2) as dependency_1.quivr.models.VerificationKey;
            }
            set verificationKey(value: dependency_1.quivr.models.VerificationKey) {
                pb_1.Message.setWrapperField(this, 2, value);
            }
            get has_verificationKey() {
                return pb_1.Message.getField(this, 2) != null;
            }
            static fromObject(data: {
                routine?: string;
                verificationKey?: ReturnType<typeof dependency_1.quivr.models.VerificationKey.prototype.toObject>;
            }): DigitalSignature {
                const message = new DigitalSignature({});
                if (data.routine != null) {
                    message.routine = data.routine;
                }
                if (data.verificationKey != null) {
                    message.verificationKey = dependency_1.quivr.models.VerificationKey.fromObject(data.verificationKey);
                }
                return message;
            }
            toObject() {
                const data: {
                    routine?: string;
                    verificationKey?: ReturnType<typeof dependency_1.quivr.models.VerificationKey.prototype.toObject>;
                } = {};
                if (this.routine != null) {
                    data.routine = this.routine;
                }
                if (this.verificationKey != null) {
                    data.verificationKey = this.verificationKey.toObject();
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.routine.length)
                    writer.writeString(1, this.routine);
                if (this.has_verificationKey)
                    writer.writeMessage(2, this.verificationKey, () => this.verificationKey.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DigitalSignature {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new DigitalSignature();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.routine = reader.readString();
                            break;
                        case 2:
                            reader.readMessage(message.verificationKey, () => message.verificationKey = dependency_1.quivr.models.VerificationKey.deserialize(reader));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): DigitalSignature {
                return DigitalSignature.deserialize(bytes);
            }
        }
        export class HeightRange extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                chain?: string;
                min?: number;
                max?: number;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("chain" in data && data.chain != undefined) {
                        this.chain = data.chain;
                    }
                    if ("min" in data && data.min != undefined) {
                        this.min = data.min;
                    }
                    if ("max" in data && data.max != undefined) {
                        this.max = data.max;
                    }
                }
            }
            get chain() {
                return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
            }
            set chain(value: string) {
                pb_1.Message.setField(this, 1, value);
            }
            get min() {
                return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
            }
            set min(value: number) {
                pb_1.Message.setField(this, 2, value);
            }
            get max() {
                return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
            }
            set max(value: number) {
                pb_1.Message.setField(this, 3, value);
            }
            static fromObject(data: {
                chain?: string;
                min?: number;
                max?: number;
            }): HeightRange {
                const message = new HeightRange({});
                if (data.chain != null) {
                    message.chain = data.chain;
                }
                if (data.min != null) {
                    message.min = data.min;
                }
                if (data.max != null) {
                    message.max = data.max;
                }
                return message;
            }
            toObject() {
                const data: {
                    chain?: string;
                    min?: number;
                    max?: number;
                } = {};
                if (this.chain != null) {
                    data.chain = this.chain;
                }
                if (this.min != null) {
                    data.min = this.min;
                }
                if (this.max != null) {
                    data.max = this.max;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.chain.length)
                    writer.writeString(1, this.chain);
                if (this.min != 0)
                    writer.writeUint64(2, this.min);
                if (this.max != 0)
                    writer.writeUint64(3, this.max);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): HeightRange {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new HeightRange();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.chain = reader.readString();
                            break;
                        case 2:
                            message.min = reader.readUint64();
                            break;
                        case 3:
                            message.max = reader.readUint64();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): HeightRange {
                return HeightRange.deserialize(bytes);
            }
        }
        export class TickRange extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                min?: number;
                max?: number;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("min" in data && data.min != undefined) {
                        this.min = data.min;
                    }
                    if ("max" in data && data.max != undefined) {
                        this.max = data.max;
                    }
                }
            }
            get min() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set min(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get max() {
                return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
            }
            set max(value: number) {
                pb_1.Message.setField(this, 2, value);
            }
            static fromObject(data: {
                min?: number;
                max?: number;
            }): TickRange {
                const message = new TickRange({});
                if (data.min != null) {
                    message.min = data.min;
                }
                if (data.max != null) {
                    message.max = data.max;
                }
                return message;
            }
            toObject() {
                const data: {
                    min?: number;
                    max?: number;
                } = {};
                if (this.min != null) {
                    data.min = this.min;
                }
                if (this.max != null) {
                    data.max = this.max;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.min != 0)
                    writer.writeUint64(1, this.min);
                if (this.max != 0)
                    writer.writeUint64(2, this.max);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TickRange {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TickRange();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.min = reader.readUint64();
                            break;
                        case 2:
                            message.max = reader.readUint64();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): TickRange {
                return TickRange.deserialize(bytes);
            }
        }
        export class ExactMatch extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                location?: string;
                compareTo?: Uint8Array;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("location" in data && data.location != undefined) {
                        this.location = data.location;
                    }
                    if ("compareTo" in data && data.compareTo != undefined) {
                        this.compareTo = data.compareTo;
                    }
                }
            }
            get location() {
                return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
            }
            set location(value: string) {
                pb_1.Message.setField(this, 1, value);
            }
            get compareTo() {
                return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array(0)) as Uint8Array;
            }
            set compareTo(value: Uint8Array) {
                pb_1.Message.setField(this, 2, value);
            }
            static fromObject(data: {
                location?: string;
                compareTo?: Uint8Array;
            }): ExactMatch {
                const message = new ExactMatch({});
                if (data.location != null) {
                    message.location = data.location;
                }
                if (data.compareTo != null) {
                    message.compareTo = data.compareTo;
                }
                return message;
            }
            toObject() {
                const data: {
                    location?: string;
                    compareTo?: Uint8Array;
                } = {};
                if (this.location != null) {
                    data.location = this.location;
                }
                if (this.compareTo != null) {
                    data.compareTo = this.compareTo;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.location.length)
                    writer.writeString(1, this.location);
                if (this.compareTo.length)
                    writer.writeBytes(2, this.compareTo);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ExactMatch {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ExactMatch();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.location = reader.readString();
                            break;
                        case 2:
                            message.compareTo = reader.readBytes();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): ExactMatch {
                return ExactMatch.deserialize(bytes);
            }
        }
        export class LessThan extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                location?: string;
                compareTo?: dependency_1.quivr.models.Int128;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("location" in data && data.location != undefined) {
                        this.location = data.location;
                    }
                    if ("compareTo" in data && data.compareTo != undefined) {
                        this.compareTo = data.compareTo;
                    }
                }
            }
            get location() {
                return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
            }
            set location(value: string) {
                pb_1.Message.setField(this, 1, value);
            }
            get compareTo() {
                return pb_1.Message.getWrapperField(this, dependency_1.quivr.models.Int128, 2) as dependency_1.quivr.models.Int128;
            }
            set compareTo(value: dependency_1.quivr.models.Int128) {
                pb_1.Message.setWrapperField(this, 2, value);
            }
            get has_compareTo() {
                return pb_1.Message.getField(this, 2) != null;
            }
            static fromObject(data: {
                location?: string;
                compareTo?: ReturnType<typeof dependency_1.quivr.models.Int128.prototype.toObject>;
            }): LessThan {
                const message = new LessThan({});
                if (data.location != null) {
                    message.location = data.location;
                }
                if (data.compareTo != null) {
                    message.compareTo = dependency_1.quivr.models.Int128.fromObject(data.compareTo);
                }
                return message;
            }
            toObject() {
                const data: {
                    location?: string;
                    compareTo?: ReturnType<typeof dependency_1.quivr.models.Int128.prototype.toObject>;
                } = {};
                if (this.location != null) {
                    data.location = this.location;
                }
                if (this.compareTo != null) {
                    data.compareTo = this.compareTo.toObject();
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.location.length)
                    writer.writeString(1, this.location);
                if (this.has_compareTo)
                    writer.writeMessage(2, this.compareTo, () => this.compareTo.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): LessThan {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new LessThan();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.location = reader.readString();
                            break;
                        case 2:
                            reader.readMessage(message.compareTo, () => message.compareTo = dependency_1.quivr.models.Int128.deserialize(reader));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): LessThan {
                return LessThan.deserialize(bytes);
            }
        }
        export class GreaterThan extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                location?: string;
                compareTo?: dependency_1.quivr.models.Int128;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("location" in data && data.location != undefined) {
                        this.location = data.location;
                    }
                    if ("compareTo" in data && data.compareTo != undefined) {
                        this.compareTo = data.compareTo;
                    }
                }
            }
            get location() {
                return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
            }
            set location(value: string) {
                pb_1.Message.setField(this, 1, value);
            }
            get compareTo() {
                return pb_1.Message.getWrapperField(this, dependency_1.quivr.models.Int128, 2) as dependency_1.quivr.models.Int128;
            }
            set compareTo(value: dependency_1.quivr.models.Int128) {
                pb_1.Message.setWrapperField(this, 2, value);
            }
            get has_compareTo() {
                return pb_1.Message.getField(this, 2) != null;
            }
            static fromObject(data: {
                location?: string;
                compareTo?: ReturnType<typeof dependency_1.quivr.models.Int128.prototype.toObject>;
            }): GreaterThan {
                const message = new GreaterThan({});
                if (data.location != null) {
                    message.location = data.location;
                }
                if (data.compareTo != null) {
                    message.compareTo = dependency_1.quivr.models.Int128.fromObject(data.compareTo);
                }
                return message;
            }
            toObject() {
                const data: {
                    location?: string;
                    compareTo?: ReturnType<typeof dependency_1.quivr.models.Int128.prototype.toObject>;
                } = {};
                if (this.location != null) {
                    data.location = this.location;
                }
                if (this.compareTo != null) {
                    data.compareTo = this.compareTo.toObject();
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.location.length)
                    writer.writeString(1, this.location);
                if (this.has_compareTo)
                    writer.writeMessage(2, this.compareTo, () => this.compareTo.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GreaterThan {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GreaterThan();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.location = reader.readString();
                            break;
                        case 2:
                            reader.readMessage(message.compareTo, () => message.compareTo = dependency_1.quivr.models.Int128.deserialize(reader));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): GreaterThan {
                return GreaterThan.deserialize(bytes);
            }
        }
        export class EqualTo extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                location?: string;
                compareTo?: dependency_1.quivr.models.Int128;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("location" in data && data.location != undefined) {
                        this.location = data.location;
                    }
                    if ("compareTo" in data && data.compareTo != undefined) {
                        this.compareTo = data.compareTo;
                    }
                }
            }
            get location() {
                return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
            }
            set location(value: string) {
                pb_1.Message.setField(this, 1, value);
            }
            get compareTo() {
                return pb_1.Message.getWrapperField(this, dependency_1.quivr.models.Int128, 2) as dependency_1.quivr.models.Int128;
            }
            set compareTo(value: dependency_1.quivr.models.Int128) {
                pb_1.Message.setWrapperField(this, 2, value);
            }
            get has_compareTo() {
                return pb_1.Message.getField(this, 2) != null;
            }
            static fromObject(data: {
                location?: string;
                compareTo?: ReturnType<typeof dependency_1.quivr.models.Int128.prototype.toObject>;
            }): EqualTo {
                const message = new EqualTo({});
                if (data.location != null) {
                    message.location = data.location;
                }
                if (data.compareTo != null) {
                    message.compareTo = dependency_1.quivr.models.Int128.fromObject(data.compareTo);
                }
                return message;
            }
            toObject() {
                const data: {
                    location?: string;
                    compareTo?: ReturnType<typeof dependency_1.quivr.models.Int128.prototype.toObject>;
                } = {};
                if (this.location != null) {
                    data.location = this.location;
                }
                if (this.compareTo != null) {
                    data.compareTo = this.compareTo.toObject();
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.location.length)
                    writer.writeString(1, this.location);
                if (this.has_compareTo)
                    writer.writeMessage(2, this.compareTo, () => this.compareTo.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EqualTo {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new EqualTo();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.location = reader.readString();
                            break;
                        case 2:
                            reader.readMessage(message.compareTo, () => message.compareTo = dependency_1.quivr.models.Int128.deserialize(reader));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): EqualTo {
                return EqualTo.deserialize(bytes);
            }
        }
        export class Threshold extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                challenges?: Proposition[];
                threshold?: number;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("challenges" in data && data.challenges != undefined) {
                        this.challenges = data.challenges;
                    }
                    if ("threshold" in data && data.threshold != undefined) {
                        this.threshold = data.threshold;
                    }
                }
            }
            get challenges() {
                return pb_1.Message.getRepeatedWrapperField(this, Proposition, 1) as Proposition[];
            }
            set challenges(value: Proposition[]) {
                pb_1.Message.setRepeatedWrapperField(this, 1, value);
            }
            get threshold() {
                return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
            }
            set threshold(value: number) {
                pb_1.Message.setField(this, 2, value);
            }
            static fromObject(data: {
                challenges?: ReturnType<typeof Proposition.prototype.toObject>[];
                threshold?: number;
            }): Threshold {
                const message = new Threshold({});
                if (data.challenges != null) {
                    message.challenges = data.challenges.map(item => Proposition.fromObject(item));
                }
                if (data.threshold != null) {
                    message.threshold = data.threshold;
                }
                return message;
            }
            toObject() {
                const data: {
                    challenges?: ReturnType<typeof Proposition.prototype.toObject>[];
                    threshold?: number;
                } = {};
                if (this.challenges != null) {
                    data.challenges = this.challenges.map((item: Proposition) => item.toObject());
                }
                if (this.threshold != null) {
                    data.threshold = this.threshold;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.challenges.length)
                    writer.writeRepeatedMessage(1, this.challenges, (item: Proposition) => item.serialize(writer));
                if (this.threshold != 0)
                    writer.writeUint32(2, this.threshold);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Threshold {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Threshold();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.challenges, () => pb_1.Message.addToRepeatedWrapperField(message, 1, Proposition.deserialize(reader), Proposition));
                            break;
                        case 2:
                            message.threshold = reader.readUint32();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Threshold {
                return Threshold.deserialize(bytes);
            }
        }
        export class Not extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                proposition?: Proposition;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("proposition" in data && data.proposition != undefined) {
                        this.proposition = data.proposition;
                    }
                }
            }
            get proposition() {
                return pb_1.Message.getWrapperField(this, Proposition, 1) as Proposition;
            }
            set proposition(value: Proposition) {
                pb_1.Message.setWrapperField(this, 1, value);
            }
            get has_proposition() {
                return pb_1.Message.getField(this, 1) != null;
            }
            static fromObject(data: {
                proposition?: ReturnType<typeof Proposition.prototype.toObject>;
            }): Not {
                const message = new Not({});
                if (data.proposition != null) {
                    message.proposition = Proposition.fromObject(data.proposition);
                }
                return message;
            }
            toObject() {
                const data: {
                    proposition?: ReturnType<typeof Proposition.prototype.toObject>;
                } = {};
                if (this.proposition != null) {
                    data.proposition = this.proposition.toObject();
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.has_proposition)
                    writer.writeMessage(1, this.proposition, () => this.proposition.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Not {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Not();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.proposition, () => message.proposition = Proposition.deserialize(reader));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Not {
                return Not.deserialize(bytes);
            }
        }
        export class And extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                left?: Proposition;
                right?: Proposition;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("left" in data && data.left != undefined) {
                        this.left = data.left;
                    }
                    if ("right" in data && data.right != undefined) {
                        this.right = data.right;
                    }
                }
            }
            get left() {
                return pb_1.Message.getWrapperField(this, Proposition, 1) as Proposition;
            }
            set left(value: Proposition) {
                pb_1.Message.setWrapperField(this, 1, value);
            }
            get has_left() {
                return pb_1.Message.getField(this, 1) != null;
            }
            get right() {
                return pb_1.Message.getWrapperField(this, Proposition, 2) as Proposition;
            }
            set right(value: Proposition) {
                pb_1.Message.setWrapperField(this, 2, value);
            }
            get has_right() {
                return pb_1.Message.getField(this, 2) != null;
            }
            static fromObject(data: {
                left?: ReturnType<typeof Proposition.prototype.toObject>;
                right?: ReturnType<typeof Proposition.prototype.toObject>;
            }): And {
                const message = new And({});
                if (data.left != null) {
                    message.left = Proposition.fromObject(data.left);
                }
                if (data.right != null) {
                    message.right = Proposition.fromObject(data.right);
                }
                return message;
            }
            toObject() {
                const data: {
                    left?: ReturnType<typeof Proposition.prototype.toObject>;
                    right?: ReturnType<typeof Proposition.prototype.toObject>;
                } = {};
                if (this.left != null) {
                    data.left = this.left.toObject();
                }
                if (this.right != null) {
                    data.right = this.right.toObject();
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.has_left)
                    writer.writeMessage(1, this.left, () => this.left.serialize(writer));
                if (this.has_right)
                    writer.writeMessage(2, this.right, () => this.right.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): And {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new And();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.left, () => message.left = Proposition.deserialize(reader));
                            break;
                        case 2:
                            reader.readMessage(message.right, () => message.right = Proposition.deserialize(reader));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): And {
                return And.deserialize(bytes);
            }
        }
        export class Or extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                left?: Proposition;
                right?: Proposition;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("left" in data && data.left != undefined) {
                        this.left = data.left;
                    }
                    if ("right" in data && data.right != undefined) {
                        this.right = data.right;
                    }
                }
            }
            get left() {
                return pb_1.Message.getWrapperField(this, Proposition, 1) as Proposition;
            }
            set left(value: Proposition) {
                pb_1.Message.setWrapperField(this, 1, value);
            }
            get has_left() {
                return pb_1.Message.getField(this, 1) != null;
            }
            get right() {
                return pb_1.Message.getWrapperField(this, Proposition, 2) as Proposition;
            }
            set right(value: Proposition) {
                pb_1.Message.setWrapperField(this, 2, value);
            }
            get has_right() {
                return pb_1.Message.getField(this, 2) != null;
            }
            static fromObject(data: {
                left?: ReturnType<typeof Proposition.prototype.toObject>;
                right?: ReturnType<typeof Proposition.prototype.toObject>;
            }): Or {
                const message = new Or({});
                if (data.left != null) {
                    message.left = Proposition.fromObject(data.left);
                }
                if (data.right != null) {
                    message.right = Proposition.fromObject(data.right);
                }
                return message;
            }
            toObject() {
                const data: {
                    left?: ReturnType<typeof Proposition.prototype.toObject>;
                    right?: ReturnType<typeof Proposition.prototype.toObject>;
                } = {};
                if (this.left != null) {
                    data.left = this.left.toObject();
                }
                if (this.right != null) {
                    data.right = this.right.toObject();
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.has_left)
                    writer.writeMessage(1, this.left, () => this.left.serialize(writer));
                if (this.has_right)
                    writer.writeMessage(2, this.right, () => this.right.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Or {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Or();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.left, () => message.left = Proposition.deserialize(reader));
                            break;
                        case 2:
                            reader.readMessage(message.right, () => message.right = Proposition.deserialize(reader));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Or {
                return Or.deserialize(bytes);
            }
        }
    }
}
