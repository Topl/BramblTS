/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.6.1
 * source: quivr/models/proof.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./shared";
import * as dependency_2 from "./../../validate/validate";
import * as pb_1 from "google-protobuf";
export namespace quivr.models {
    export class Proof extends pb_1.Message {
        #one_of_decls: number[][] = [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]];
        constructor(data?: any[] | ({} & (({
            locked?: Proof.Locked;
            digest?: never;
            digitalSignature?: never;
            heightRange?: never;
            tickRange?: never;
            exactMatch?: never;
            lessThan?: never;
            greaterThan?: never;
            equalTo?: never;
            threshold?: never;
            not?: never;
            and?: never;
            or?: never;
        } | {
            locked?: never;
            digest?: Proof.Digest;
            digitalSignature?: never;
            heightRange?: never;
            tickRange?: never;
            exactMatch?: never;
            lessThan?: never;
            greaterThan?: never;
            equalTo?: never;
            threshold?: never;
            not?: never;
            and?: never;
            or?: never;
        } | {
            locked?: never;
            digest?: never;
            digitalSignature?: Proof.DigitalSignature;
            heightRange?: never;
            tickRange?: never;
            exactMatch?: never;
            lessThan?: never;
            greaterThan?: never;
            equalTo?: never;
            threshold?: never;
            not?: never;
            and?: never;
            or?: never;
        } | {
            locked?: never;
            digest?: never;
            digitalSignature?: never;
            heightRange?: Proof.HeightRange;
            tickRange?: never;
            exactMatch?: never;
            lessThan?: never;
            greaterThan?: never;
            equalTo?: never;
            threshold?: never;
            not?: never;
            and?: never;
            or?: never;
        } | {
            locked?: never;
            digest?: never;
            digitalSignature?: never;
            heightRange?: never;
            tickRange?: Proof.TickRange;
            exactMatch?: never;
            lessThan?: never;
            greaterThan?: never;
            equalTo?: never;
            threshold?: never;
            not?: never;
            and?: never;
            or?: never;
        } | {
            locked?: never;
            digest?: never;
            digitalSignature?: never;
            heightRange?: never;
            tickRange?: never;
            exactMatch?: Proof.ExactMatch;
            lessThan?: never;
            greaterThan?: never;
            equalTo?: never;
            threshold?: never;
            not?: never;
            and?: never;
            or?: never;
        } | {
            locked?: never;
            digest?: never;
            digitalSignature?: never;
            heightRange?: never;
            tickRange?: never;
            exactMatch?: never;
            lessThan?: Proof.LessThan;
            greaterThan?: never;
            equalTo?: never;
            threshold?: never;
            not?: never;
            and?: never;
            or?: never;
        } | {
            locked?: never;
            digest?: never;
            digitalSignature?: never;
            heightRange?: never;
            tickRange?: never;
            exactMatch?: never;
            lessThan?: never;
            greaterThan?: Proof.GreaterThan;
            equalTo?: never;
            threshold?: never;
            not?: never;
            and?: never;
            or?: never;
        } | {
            locked?: never;
            digest?: never;
            digitalSignature?: never;
            heightRange?: never;
            tickRange?: never;
            exactMatch?: never;
            lessThan?: never;
            greaterThan?: never;
            equalTo?: Proof.EqualTo;
            threshold?: never;
            not?: never;
            and?: never;
            or?: never;
        } | {
            locked?: never;
            digest?: never;
            digitalSignature?: never;
            heightRange?: never;
            tickRange?: never;
            exactMatch?: never;
            lessThan?: never;
            greaterThan?: never;
            equalTo?: never;
            threshold?: Proof.Threshold;
            not?: never;
            and?: never;
            or?: never;
        } | {
            locked?: never;
            digest?: never;
            digitalSignature?: never;
            heightRange?: never;
            tickRange?: never;
            exactMatch?: never;
            lessThan?: never;
            greaterThan?: never;
            equalTo?: never;
            threshold?: never;
            not?: Proof.Not;
            and?: never;
            or?: never;
        } | {
            locked?: never;
            digest?: never;
            digitalSignature?: never;
            heightRange?: never;
            tickRange?: never;
            exactMatch?: never;
            lessThan?: never;
            greaterThan?: never;
            equalTo?: never;
            threshold?: never;
            not?: never;
            and?: Proof.And;
            or?: never;
        } | {
            locked?: never;
            digest?: never;
            digitalSignature?: never;
            heightRange?: never;
            tickRange?: never;
            exactMatch?: never;
            lessThan?: never;
            greaterThan?: never;
            equalTo?: never;
            threshold?: never;
            not?: never;
            and?: never;
            or?: Proof.Or;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("locked" in data && data.locked != undefined) {
                    this.locked = data.locked;
                }
                if ("digest" in data && data.digest != undefined) {
                    this.digest = data.digest;
                }
                if ("digitalSignature" in data && data.digitalSignature != undefined) {
                    this.digitalSignature = data.digitalSignature;
                }
                if ("heightRange" in data && data.heightRange != undefined) {
                    this.heightRange = data.heightRange;
                }
                if ("tickRange" in data && data.tickRange != undefined) {
                    this.tickRange = data.tickRange;
                }
                if ("exactMatch" in data && data.exactMatch != undefined) {
                    this.exactMatch = data.exactMatch;
                }
                if ("lessThan" in data && data.lessThan != undefined) {
                    this.lessThan = data.lessThan;
                }
                if ("greaterThan" in data && data.greaterThan != undefined) {
                    this.greaterThan = data.greaterThan;
                }
                if ("equalTo" in data && data.equalTo != undefined) {
                    this.equalTo = data.equalTo;
                }
                if ("threshold" in data && data.threshold != undefined) {
                    this.threshold = data.threshold;
                }
                if ("not" in data && data.not != undefined) {
                    this.not = data.not;
                }
                if ("and" in data && data.and != undefined) {
                    this.and = data.and;
                }
                if ("or" in data && data.or != undefined) {
                    this.or = data.or;
                }
            }
        }
        get locked() {
            return pb_1.Message.getWrapperField(this, Proof.Locked, 1) as Proof.Locked;
        }
        set locked(value: Proof.Locked) {
            pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
        }
        get has_locked() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get digest() {
            return pb_1.Message.getWrapperField(this, Proof.Digest, 2) as Proof.Digest;
        }
        set digest(value: Proof.Digest) {
            pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
        }
        get has_digest() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get digitalSignature() {
            return pb_1.Message.getWrapperField(this, Proof.DigitalSignature, 3) as Proof.DigitalSignature;
        }
        set digitalSignature(value: Proof.DigitalSignature) {
            pb_1.Message.setOneofWrapperField(this, 3, this.#one_of_decls[0], value);
        }
        get has_digitalSignature() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get heightRange() {
            return pb_1.Message.getWrapperField(this, Proof.HeightRange, 4) as Proof.HeightRange;
        }
        set heightRange(value: Proof.HeightRange) {
            pb_1.Message.setOneofWrapperField(this, 4, this.#one_of_decls[0], value);
        }
        get has_heightRange() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get tickRange() {
            return pb_1.Message.getWrapperField(this, Proof.TickRange, 5) as Proof.TickRange;
        }
        set tickRange(value: Proof.TickRange) {
            pb_1.Message.setOneofWrapperField(this, 5, this.#one_of_decls[0], value);
        }
        get has_tickRange() {
            return pb_1.Message.getField(this, 5) != null;
        }
        get exactMatch() {
            return pb_1.Message.getWrapperField(this, Proof.ExactMatch, 6) as Proof.ExactMatch;
        }
        set exactMatch(value: Proof.ExactMatch) {
            pb_1.Message.setOneofWrapperField(this, 6, this.#one_of_decls[0], value);
        }
        get has_exactMatch() {
            return pb_1.Message.getField(this, 6) != null;
        }
        get lessThan() {
            return pb_1.Message.getWrapperField(this, Proof.LessThan, 7) as Proof.LessThan;
        }
        set lessThan(value: Proof.LessThan) {
            pb_1.Message.setOneofWrapperField(this, 7, this.#one_of_decls[0], value);
        }
        get has_lessThan() {
            return pb_1.Message.getField(this, 7) != null;
        }
        get greaterThan() {
            return pb_1.Message.getWrapperField(this, Proof.GreaterThan, 8) as Proof.GreaterThan;
        }
        set greaterThan(value: Proof.GreaterThan) {
            pb_1.Message.setOneofWrapperField(this, 8, this.#one_of_decls[0], value);
        }
        get has_greaterThan() {
            return pb_1.Message.getField(this, 8) != null;
        }
        get equalTo() {
            return pb_1.Message.getWrapperField(this, Proof.EqualTo, 9) as Proof.EqualTo;
        }
        set equalTo(value: Proof.EqualTo) {
            pb_1.Message.setOneofWrapperField(this, 9, this.#one_of_decls[0], value);
        }
        get has_equalTo() {
            return pb_1.Message.getField(this, 9) != null;
        }
        get threshold() {
            return pb_1.Message.getWrapperField(this, Proof.Threshold, 10) as Proof.Threshold;
        }
        set threshold(value: Proof.Threshold) {
            pb_1.Message.setOneofWrapperField(this, 10, this.#one_of_decls[0], value);
        }
        get has_threshold() {
            return pb_1.Message.getField(this, 10) != null;
        }
        get not() {
            return pb_1.Message.getWrapperField(this, Proof.Not, 11) as Proof.Not;
        }
        set not(value: Proof.Not) {
            pb_1.Message.setOneofWrapperField(this, 11, this.#one_of_decls[0], value);
        }
        get has_not() {
            return pb_1.Message.getField(this, 11) != null;
        }
        get and() {
            return pb_1.Message.getWrapperField(this, Proof.And, 12) as Proof.And;
        }
        set and(value: Proof.And) {
            pb_1.Message.setOneofWrapperField(this, 12, this.#one_of_decls[0], value);
        }
        get has_and() {
            return pb_1.Message.getField(this, 12) != null;
        }
        get or() {
            return pb_1.Message.getWrapperField(this, Proof.Or, 13) as Proof.Or;
        }
        set or(value: Proof.Or) {
            pb_1.Message.setOneofWrapperField(this, 13, this.#one_of_decls[0], value);
        }
        get has_or() {
            return pb_1.Message.getField(this, 13) != null;
        }
        get value() {
            const cases: {
                [index: number]: "none" | "locked" | "digest" | "digitalSignature" | "heightRange" | "tickRange" | "exactMatch" | "lessThan" | "greaterThan" | "equalTo" | "threshold" | "not" | "and" | "or";
            } = {
                0: "none",
                1: "locked",
                2: "digest",
                3: "digitalSignature",
                4: "heightRange",
                5: "tickRange",
                6: "exactMatch",
                7: "lessThan",
                8: "greaterThan",
                9: "equalTo",
                10: "threshold",
                11: "not",
                12: "and",
                13: "or"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13])];
        }
        static fromObject(data: {
            locked?: ReturnType<typeof Proof.Locked.prototype.toObject>;
            digest?: ReturnType<typeof Proof.Digest.prototype.toObject>;
            digitalSignature?: ReturnType<typeof Proof.DigitalSignature.prototype.toObject>;
            heightRange?: ReturnType<typeof Proof.HeightRange.prototype.toObject>;
            tickRange?: ReturnType<typeof Proof.TickRange.prototype.toObject>;
            exactMatch?: ReturnType<typeof Proof.ExactMatch.prototype.toObject>;
            lessThan?: ReturnType<typeof Proof.LessThan.prototype.toObject>;
            greaterThan?: ReturnType<typeof Proof.GreaterThan.prototype.toObject>;
            equalTo?: ReturnType<typeof Proof.EqualTo.prototype.toObject>;
            threshold?: ReturnType<typeof Proof.Threshold.prototype.toObject>;
            not?: ReturnType<typeof Proof.Not.prototype.toObject>;
            and?: ReturnType<typeof Proof.And.prototype.toObject>;
            or?: ReturnType<typeof Proof.Or.prototype.toObject>;
        }): Proof {
            const message = new Proof({});
            if (data.locked != null) {
                message.locked = Proof.Locked.fromObject(data.locked);
            }
            if (data.digest != null) {
                message.digest = Proof.Digest.fromObject(data.digest);
            }
            if (data.digitalSignature != null) {
                message.digitalSignature = Proof.DigitalSignature.fromObject(data.digitalSignature);
            }
            if (data.heightRange != null) {
                message.heightRange = Proof.HeightRange.fromObject(data.heightRange);
            }
            if (data.tickRange != null) {
                message.tickRange = Proof.TickRange.fromObject(data.tickRange);
            }
            if (data.exactMatch != null) {
                message.exactMatch = Proof.ExactMatch.fromObject(data.exactMatch);
            }
            if (data.lessThan != null) {
                message.lessThan = Proof.LessThan.fromObject(data.lessThan);
            }
            if (data.greaterThan != null) {
                message.greaterThan = Proof.GreaterThan.fromObject(data.greaterThan);
            }
            if (data.equalTo != null) {
                message.equalTo = Proof.EqualTo.fromObject(data.equalTo);
            }
            if (data.threshold != null) {
                message.threshold = Proof.Threshold.fromObject(data.threshold);
            }
            if (data.not != null) {
                message.not = Proof.Not.fromObject(data.not);
            }
            if (data.and != null) {
                message.and = Proof.And.fromObject(data.and);
            }
            if (data.or != null) {
                message.or = Proof.Or.fromObject(data.or);
            }
            return message;
        }
        toObject() {
            const data: {
                locked?: ReturnType<typeof Proof.Locked.prototype.toObject>;
                digest?: ReturnType<typeof Proof.Digest.prototype.toObject>;
                digitalSignature?: ReturnType<typeof Proof.DigitalSignature.prototype.toObject>;
                heightRange?: ReturnType<typeof Proof.HeightRange.prototype.toObject>;
                tickRange?: ReturnType<typeof Proof.TickRange.prototype.toObject>;
                exactMatch?: ReturnType<typeof Proof.ExactMatch.prototype.toObject>;
                lessThan?: ReturnType<typeof Proof.LessThan.prototype.toObject>;
                greaterThan?: ReturnType<typeof Proof.GreaterThan.prototype.toObject>;
                equalTo?: ReturnType<typeof Proof.EqualTo.prototype.toObject>;
                threshold?: ReturnType<typeof Proof.Threshold.prototype.toObject>;
                not?: ReturnType<typeof Proof.Not.prototype.toObject>;
                and?: ReturnType<typeof Proof.And.prototype.toObject>;
                or?: ReturnType<typeof Proof.Or.prototype.toObject>;
            } = {};
            if (this.locked != null) {
                data.locked = this.locked.toObject();
            }
            if (this.digest != null) {
                data.digest = this.digest.toObject();
            }
            if (this.digitalSignature != null) {
                data.digitalSignature = this.digitalSignature.toObject();
            }
            if (this.heightRange != null) {
                data.heightRange = this.heightRange.toObject();
            }
            if (this.tickRange != null) {
                data.tickRange = this.tickRange.toObject();
            }
            if (this.exactMatch != null) {
                data.exactMatch = this.exactMatch.toObject();
            }
            if (this.lessThan != null) {
                data.lessThan = this.lessThan.toObject();
            }
            if (this.greaterThan != null) {
                data.greaterThan = this.greaterThan.toObject();
            }
            if (this.equalTo != null) {
                data.equalTo = this.equalTo.toObject();
            }
            if (this.threshold != null) {
                data.threshold = this.threshold.toObject();
            }
            if (this.not != null) {
                data.not = this.not.toObject();
            }
            if (this.and != null) {
                data.and = this.and.toObject();
            }
            if (this.or != null) {
                data.or = this.or.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_locked)
                writer.writeMessage(1, this.locked, () => this.locked.serialize(writer));
            if (this.has_digest)
                writer.writeMessage(2, this.digest, () => this.digest.serialize(writer));
            if (this.has_digitalSignature)
                writer.writeMessage(3, this.digitalSignature, () => this.digitalSignature.serialize(writer));
            if (this.has_heightRange)
                writer.writeMessage(4, this.heightRange, () => this.heightRange.serialize(writer));
            if (this.has_tickRange)
                writer.writeMessage(5, this.tickRange, () => this.tickRange.serialize(writer));
            if (this.has_exactMatch)
                writer.writeMessage(6, this.exactMatch, () => this.exactMatch.serialize(writer));
            if (this.has_lessThan)
                writer.writeMessage(7, this.lessThan, () => this.lessThan.serialize(writer));
            if (this.has_greaterThan)
                writer.writeMessage(8, this.greaterThan, () => this.greaterThan.serialize(writer));
            if (this.has_equalTo)
                writer.writeMessage(9, this.equalTo, () => this.equalTo.serialize(writer));
            if (this.has_threshold)
                writer.writeMessage(10, this.threshold, () => this.threshold.serialize(writer));
            if (this.has_not)
                writer.writeMessage(11, this.not, () => this.not.serialize(writer));
            if (this.has_and)
                writer.writeMessage(12, this.and, () => this.and.serialize(writer));
            if (this.has_or)
                writer.writeMessage(13, this.or, () => this.or.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Proof {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Proof();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.locked, () => message.locked = Proof.Locked.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.digest, () => message.digest = Proof.Digest.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.digitalSignature, () => message.digitalSignature = Proof.DigitalSignature.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.heightRange, () => message.heightRange = Proof.HeightRange.deserialize(reader));
                        break;
                    case 5:
                        reader.readMessage(message.tickRange, () => message.tickRange = Proof.TickRange.deserialize(reader));
                        break;
                    case 6:
                        reader.readMessage(message.exactMatch, () => message.exactMatch = Proof.ExactMatch.deserialize(reader));
                        break;
                    case 7:
                        reader.readMessage(message.lessThan, () => message.lessThan = Proof.LessThan.deserialize(reader));
                        break;
                    case 8:
                        reader.readMessage(message.greaterThan, () => message.greaterThan = Proof.GreaterThan.deserialize(reader));
                        break;
                    case 9:
                        reader.readMessage(message.equalTo, () => message.equalTo = Proof.EqualTo.deserialize(reader));
                        break;
                    case 10:
                        reader.readMessage(message.threshold, () => message.threshold = Proof.Threshold.deserialize(reader));
                        break;
                    case 11:
                        reader.readMessage(message.not, () => message.not = Proof.Not.deserialize(reader));
                        break;
                    case 12:
                        reader.readMessage(message.and, () => message.and = Proof.And.deserialize(reader));
                        break;
                    case 13:
                        reader.readMessage(message.or, () => message.or = Proof.Or.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Proof {
            return Proof.deserialize(bytes);
        }
    }
    export namespace Proof {
        export class Locked extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {}) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") { }
            }
            static fromObject(data: {}): Locked {
                const message = new Locked({});
                return message;
            }
            toObject() {
                const data: {} = {};
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Locked {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Locked();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Locked {
                return Locked.deserialize(bytes);
            }
        }
        export class Digest extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                transactionBind?: dependency_1.quivr.models.TxBind;
                preimage?: dependency_1.quivr.models.Preimage;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("transactionBind" in data && data.transactionBind != undefined) {
                        this.transactionBind = data.transactionBind;
                    }
                    if ("preimage" in data && data.preimage != undefined) {
                        this.preimage = data.preimage;
                    }
                }
            }
            get transactionBind() {
                return pb_1.Message.getWrapperField(this, dependency_1.quivr.models.TxBind, 1) as dependency_1.quivr.models.TxBind;
            }
            set transactionBind(value: dependency_1.quivr.models.TxBind) {
                pb_1.Message.setWrapperField(this, 1, value);
            }
            get has_transactionBind() {
                return pb_1.Message.getField(this, 1) != null;
            }
            get preimage() {
                return pb_1.Message.getWrapperField(this, dependency_1.quivr.models.Preimage, 2) as dependency_1.quivr.models.Preimage;
            }
            set preimage(value: dependency_1.quivr.models.Preimage) {
                pb_1.Message.setWrapperField(this, 2, value);
            }
            get has_preimage() {
                return pb_1.Message.getField(this, 2) != null;
            }
            static fromObject(data: {
                transactionBind?: ReturnType<typeof dependency_1.quivr.models.TxBind.prototype.toObject>;
                preimage?: ReturnType<typeof dependency_1.quivr.models.Preimage.prototype.toObject>;
            }): Digest {
                const message = new Digest({});
                if (data.transactionBind != null) {
                    message.transactionBind = dependency_1.quivr.models.TxBind.fromObject(data.transactionBind);
                }
                if (data.preimage != null) {
                    message.preimage = dependency_1.quivr.models.Preimage.fromObject(data.preimage);
                }
                return message;
            }
            toObject() {
                const data: {
                    transactionBind?: ReturnType<typeof dependency_1.quivr.models.TxBind.prototype.toObject>;
                    preimage?: ReturnType<typeof dependency_1.quivr.models.Preimage.prototype.toObject>;
                } = {};
                if (this.transactionBind != null) {
                    data.transactionBind = this.transactionBind.toObject();
                }
                if (this.preimage != null) {
                    data.preimage = this.preimage.toObject();
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.has_transactionBind)
                    writer.writeMessage(1, this.transactionBind, () => this.transactionBind.serialize(writer));
                if (this.has_preimage)
                    writer.writeMessage(2, this.preimage, () => this.preimage.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Digest {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Digest();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.transactionBind, () => message.transactionBind = dependency_1.quivr.models.TxBind.deserialize(reader));
                            break;
                        case 2:
                            reader.readMessage(message.preimage, () => message.preimage = dependency_1.quivr.models.Preimage.deserialize(reader));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Digest {
                return Digest.deserialize(bytes);
            }
        }
        export class DigitalSignature extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                transactionBind?: dependency_1.quivr.models.TxBind;
                witness?: dependency_1.quivr.models.Witness;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("transactionBind" in data && data.transactionBind != undefined) {
                        this.transactionBind = data.transactionBind;
                    }
                    if ("witness" in data && data.witness != undefined) {
                        this.witness = data.witness;
                    }
                }
            }
            get transactionBind() {
                return pb_1.Message.getWrapperField(this, dependency_1.quivr.models.TxBind, 1) as dependency_1.quivr.models.TxBind;
            }
            set transactionBind(value: dependency_1.quivr.models.TxBind) {
                pb_1.Message.setWrapperField(this, 1, value);
            }
            get has_transactionBind() {
                return pb_1.Message.getField(this, 1) != null;
            }
            get witness() {
                return pb_1.Message.getWrapperField(this, dependency_1.quivr.models.Witness, 2) as dependency_1.quivr.models.Witness;
            }
            set witness(value: dependency_1.quivr.models.Witness) {
                pb_1.Message.setWrapperField(this, 2, value);
            }
            get has_witness() {
                return pb_1.Message.getField(this, 2) != null;
            }
            static fromObject(data: {
                transactionBind?: ReturnType<typeof dependency_1.quivr.models.TxBind.prototype.toObject>;
                witness?: ReturnType<typeof dependency_1.quivr.models.Witness.prototype.toObject>;
            }): DigitalSignature {
                const message = new DigitalSignature({});
                if (data.transactionBind != null) {
                    message.transactionBind = dependency_1.quivr.models.TxBind.fromObject(data.transactionBind);
                }
                if (data.witness != null) {
                    message.witness = dependency_1.quivr.models.Witness.fromObject(data.witness);
                }
                return message;
            }
            toObject() {
                const data: {
                    transactionBind?: ReturnType<typeof dependency_1.quivr.models.TxBind.prototype.toObject>;
                    witness?: ReturnType<typeof dependency_1.quivr.models.Witness.prototype.toObject>;
                } = {};
                if (this.transactionBind != null) {
                    data.transactionBind = this.transactionBind.toObject();
                }
                if (this.witness != null) {
                    data.witness = this.witness.toObject();
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.has_transactionBind)
                    writer.writeMessage(1, this.transactionBind, () => this.transactionBind.serialize(writer));
                if (this.has_witness)
                    writer.writeMessage(2, this.witness, () => this.witness.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DigitalSignature {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new DigitalSignature();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.transactionBind, () => message.transactionBind = dependency_1.quivr.models.TxBind.deserialize(reader));
                            break;
                        case 2:
                            reader.readMessage(message.witness, () => message.witness = dependency_1.quivr.models.Witness.deserialize(reader));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): DigitalSignature {
                return DigitalSignature.deserialize(bytes);
            }
        }
        export class HeightRange extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                transactionBind?: dependency_1.quivr.models.TxBind;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("transactionBind" in data && data.transactionBind != undefined) {
                        this.transactionBind = data.transactionBind;
                    }
                }
            }
            get transactionBind() {
                return pb_1.Message.getWrapperField(this, dependency_1.quivr.models.TxBind, 1) as dependency_1.quivr.models.TxBind;
            }
            set transactionBind(value: dependency_1.quivr.models.TxBind) {
                pb_1.Message.setWrapperField(this, 1, value);
            }
            get has_transactionBind() {
                return pb_1.Message.getField(this, 1) != null;
            }
            static fromObject(data: {
                transactionBind?: ReturnType<typeof dependency_1.quivr.models.TxBind.prototype.toObject>;
            }): HeightRange {
                const message = new HeightRange({});
                if (data.transactionBind != null) {
                    message.transactionBind = dependency_1.quivr.models.TxBind.fromObject(data.transactionBind);
                }
                return message;
            }
            toObject() {
                const data: {
                    transactionBind?: ReturnType<typeof dependency_1.quivr.models.TxBind.prototype.toObject>;
                } = {};
                if (this.transactionBind != null) {
                    data.transactionBind = this.transactionBind.toObject();
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.has_transactionBind)
                    writer.writeMessage(1, this.transactionBind, () => this.transactionBind.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): HeightRange {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new HeightRange();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.transactionBind, () => message.transactionBind = dependency_1.quivr.models.TxBind.deserialize(reader));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): HeightRange {
                return HeightRange.deserialize(bytes);
            }
        }
        export class TickRange extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                transactionBind?: dependency_1.quivr.models.TxBind;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("transactionBind" in data && data.transactionBind != undefined) {
                        this.transactionBind = data.transactionBind;
                    }
                }
            }
            get transactionBind() {
                return pb_1.Message.getWrapperField(this, dependency_1.quivr.models.TxBind, 1) as dependency_1.quivr.models.TxBind;
            }
            set transactionBind(value: dependency_1.quivr.models.TxBind) {
                pb_1.Message.setWrapperField(this, 1, value);
            }
            get has_transactionBind() {
                return pb_1.Message.getField(this, 1) != null;
            }
            static fromObject(data: {
                transactionBind?: ReturnType<typeof dependency_1.quivr.models.TxBind.prototype.toObject>;
            }): TickRange {
                const message = new TickRange({});
                if (data.transactionBind != null) {
                    message.transactionBind = dependency_1.quivr.models.TxBind.fromObject(data.transactionBind);
                }
                return message;
            }
            toObject() {
                const data: {
                    transactionBind?: ReturnType<typeof dependency_1.quivr.models.TxBind.prototype.toObject>;
                } = {};
                if (this.transactionBind != null) {
                    data.transactionBind = this.transactionBind.toObject();
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.has_transactionBind)
                    writer.writeMessage(1, this.transactionBind, () => this.transactionBind.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TickRange {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TickRange();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.transactionBind, () => message.transactionBind = dependency_1.quivr.models.TxBind.deserialize(reader));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): TickRange {
                return TickRange.deserialize(bytes);
            }
        }
        export class ExactMatch extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                transactionBind?: dependency_1.quivr.models.TxBind;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("transactionBind" in data && data.transactionBind != undefined) {
                        this.transactionBind = data.transactionBind;
                    }
                }
            }
            get transactionBind() {
                return pb_1.Message.getWrapperField(this, dependency_1.quivr.models.TxBind, 1) as dependency_1.quivr.models.TxBind;
            }
            set transactionBind(value: dependency_1.quivr.models.TxBind) {
                pb_1.Message.setWrapperField(this, 1, value);
            }
            get has_transactionBind() {
                return pb_1.Message.getField(this, 1) != null;
            }
            static fromObject(data: {
                transactionBind?: ReturnType<typeof dependency_1.quivr.models.TxBind.prototype.toObject>;
            }): ExactMatch {
                const message = new ExactMatch({});
                if (data.transactionBind != null) {
                    message.transactionBind = dependency_1.quivr.models.TxBind.fromObject(data.transactionBind);
                }
                return message;
            }
            toObject() {
                const data: {
                    transactionBind?: ReturnType<typeof dependency_1.quivr.models.TxBind.prototype.toObject>;
                } = {};
                if (this.transactionBind != null) {
                    data.transactionBind = this.transactionBind.toObject();
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.has_transactionBind)
                    writer.writeMessage(1, this.transactionBind, () => this.transactionBind.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ExactMatch {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ExactMatch();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.transactionBind, () => message.transactionBind = dependency_1.quivr.models.TxBind.deserialize(reader));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): ExactMatch {
                return ExactMatch.deserialize(bytes);
            }
        }
        export class LessThan extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                transactionBind?: dependency_1.quivr.models.TxBind;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("transactionBind" in data && data.transactionBind != undefined) {
                        this.transactionBind = data.transactionBind;
                    }
                }
            }
            get transactionBind() {
                return pb_1.Message.getWrapperField(this, dependency_1.quivr.models.TxBind, 1) as dependency_1.quivr.models.TxBind;
            }
            set transactionBind(value: dependency_1.quivr.models.TxBind) {
                pb_1.Message.setWrapperField(this, 1, value);
            }
            get has_transactionBind() {
                return pb_1.Message.getField(this, 1) != null;
            }
            static fromObject(data: {
                transactionBind?: ReturnType<typeof dependency_1.quivr.models.TxBind.prototype.toObject>;
            }): LessThan {
                const message = new LessThan({});
                if (data.transactionBind != null) {
                    message.transactionBind = dependency_1.quivr.models.TxBind.fromObject(data.transactionBind);
                }
                return message;
            }
            toObject() {
                const data: {
                    transactionBind?: ReturnType<typeof dependency_1.quivr.models.TxBind.prototype.toObject>;
                } = {};
                if (this.transactionBind != null) {
                    data.transactionBind = this.transactionBind.toObject();
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.has_transactionBind)
                    writer.writeMessage(1, this.transactionBind, () => this.transactionBind.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): LessThan {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new LessThan();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.transactionBind, () => message.transactionBind = dependency_1.quivr.models.TxBind.deserialize(reader));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): LessThan {
                return LessThan.deserialize(bytes);
            }
        }
        export class GreaterThan extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                transactionBind?: dependency_1.quivr.models.TxBind;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("transactionBind" in data && data.transactionBind != undefined) {
                        this.transactionBind = data.transactionBind;
                    }
                }
            }
            get transactionBind() {
                return pb_1.Message.getWrapperField(this, dependency_1.quivr.models.TxBind, 1) as dependency_1.quivr.models.TxBind;
            }
            set transactionBind(value: dependency_1.quivr.models.TxBind) {
                pb_1.Message.setWrapperField(this, 1, value);
            }
            get has_transactionBind() {
                return pb_1.Message.getField(this, 1) != null;
            }
            static fromObject(data: {
                transactionBind?: ReturnType<typeof dependency_1.quivr.models.TxBind.prototype.toObject>;
            }): GreaterThan {
                const message = new GreaterThan({});
                if (data.transactionBind != null) {
                    message.transactionBind = dependency_1.quivr.models.TxBind.fromObject(data.transactionBind);
                }
                return message;
            }
            toObject() {
                const data: {
                    transactionBind?: ReturnType<typeof dependency_1.quivr.models.TxBind.prototype.toObject>;
                } = {};
                if (this.transactionBind != null) {
                    data.transactionBind = this.transactionBind.toObject();
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.has_transactionBind)
                    writer.writeMessage(1, this.transactionBind, () => this.transactionBind.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GreaterThan {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GreaterThan();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.transactionBind, () => message.transactionBind = dependency_1.quivr.models.TxBind.deserialize(reader));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): GreaterThan {
                return GreaterThan.deserialize(bytes);
            }
        }
        export class EqualTo extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                transactionBind?: dependency_1.quivr.models.TxBind;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("transactionBind" in data && data.transactionBind != undefined) {
                        this.transactionBind = data.transactionBind;
                    }
                }
            }
            get transactionBind() {
                return pb_1.Message.getWrapperField(this, dependency_1.quivr.models.TxBind, 1) as dependency_1.quivr.models.TxBind;
            }
            set transactionBind(value: dependency_1.quivr.models.TxBind) {
                pb_1.Message.setWrapperField(this, 1, value);
            }
            get has_transactionBind() {
                return pb_1.Message.getField(this, 1) != null;
            }
            static fromObject(data: {
                transactionBind?: ReturnType<typeof dependency_1.quivr.models.TxBind.prototype.toObject>;
            }): EqualTo {
                const message = new EqualTo({});
                if (data.transactionBind != null) {
                    message.transactionBind = dependency_1.quivr.models.TxBind.fromObject(data.transactionBind);
                }
                return message;
            }
            toObject() {
                const data: {
                    transactionBind?: ReturnType<typeof dependency_1.quivr.models.TxBind.prototype.toObject>;
                } = {};
                if (this.transactionBind != null) {
                    data.transactionBind = this.transactionBind.toObject();
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.has_transactionBind)
                    writer.writeMessage(1, this.transactionBind, () => this.transactionBind.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EqualTo {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new EqualTo();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.transactionBind, () => message.transactionBind = dependency_1.quivr.models.TxBind.deserialize(reader));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): EqualTo {
                return EqualTo.deserialize(bytes);
            }
        }
        export class Threshold extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                transactionBind?: dependency_1.quivr.models.TxBind;
                responses?: Proof[];
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("transactionBind" in data && data.transactionBind != undefined) {
                        this.transactionBind = data.transactionBind;
                    }
                    if ("responses" in data && data.responses != undefined) {
                        this.responses = data.responses;
                    }
                }
            }
            get transactionBind() {
                return pb_1.Message.getWrapperField(this, dependency_1.quivr.models.TxBind, 1) as dependency_1.quivr.models.TxBind;
            }
            set transactionBind(value: dependency_1.quivr.models.TxBind) {
                pb_1.Message.setWrapperField(this, 1, value);
            }
            get has_transactionBind() {
                return pb_1.Message.getField(this, 1) != null;
            }
            get responses() {
                return pb_1.Message.getRepeatedWrapperField(this, Proof, 2) as Proof[];
            }
            set responses(value: Proof[]) {
                pb_1.Message.setRepeatedWrapperField(this, 2, value);
            }
            static fromObject(data: {
                transactionBind?: ReturnType<typeof dependency_1.quivr.models.TxBind.prototype.toObject>;
                responses?: ReturnType<typeof Proof.prototype.toObject>[];
            }): Threshold {
                const message = new Threshold({});
                if (data.transactionBind != null) {
                    message.transactionBind = dependency_1.quivr.models.TxBind.fromObject(data.transactionBind);
                }
                if (data.responses != null) {
                    message.responses = data.responses.map(item => Proof.fromObject(item));
                }
                return message;
            }
            toObject() {
                const data: {
                    transactionBind?: ReturnType<typeof dependency_1.quivr.models.TxBind.prototype.toObject>;
                    responses?: ReturnType<typeof Proof.prototype.toObject>[];
                } = {};
                if (this.transactionBind != null) {
                    data.transactionBind = this.transactionBind.toObject();
                }
                if (this.responses != null) {
                    data.responses = this.responses.map((item: Proof) => item.toObject());
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.has_transactionBind)
                    writer.writeMessage(1, this.transactionBind, () => this.transactionBind.serialize(writer));
                if (this.responses.length)
                    writer.writeRepeatedMessage(2, this.responses, (item: Proof) => item.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Threshold {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Threshold();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.transactionBind, () => message.transactionBind = dependency_1.quivr.models.TxBind.deserialize(reader));
                            break;
                        case 2:
                            reader.readMessage(message.responses, () => pb_1.Message.addToRepeatedWrapperField(message, 2, Proof.deserialize(reader), Proof));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Threshold {
                return Threshold.deserialize(bytes);
            }
        }
        export class Not extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                transactionBind?: dependency_1.quivr.models.TxBind;
                proof?: Proof;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("transactionBind" in data && data.transactionBind != undefined) {
                        this.transactionBind = data.transactionBind;
                    }
                    if ("proof" in data && data.proof != undefined) {
                        this.proof = data.proof;
                    }
                }
            }
            get transactionBind() {
                return pb_1.Message.getWrapperField(this, dependency_1.quivr.models.TxBind, 1) as dependency_1.quivr.models.TxBind;
            }
            set transactionBind(value: dependency_1.quivr.models.TxBind) {
                pb_1.Message.setWrapperField(this, 1, value);
            }
            get has_transactionBind() {
                return pb_1.Message.getField(this, 1) != null;
            }
            get proof() {
                return pb_1.Message.getWrapperField(this, Proof, 2) as Proof;
            }
            set proof(value: Proof) {
                pb_1.Message.setWrapperField(this, 2, value);
            }
            get has_proof() {
                return pb_1.Message.getField(this, 2) != null;
            }
            static fromObject(data: {
                transactionBind?: ReturnType<typeof dependency_1.quivr.models.TxBind.prototype.toObject>;
                proof?: ReturnType<typeof Proof.prototype.toObject>;
            }): Not {
                const message = new Not({});
                if (data.transactionBind != null) {
                    message.transactionBind = dependency_1.quivr.models.TxBind.fromObject(data.transactionBind);
                }
                if (data.proof != null) {
                    message.proof = Proof.fromObject(data.proof);
                }
                return message;
            }
            toObject() {
                const data: {
                    transactionBind?: ReturnType<typeof dependency_1.quivr.models.TxBind.prototype.toObject>;
                    proof?: ReturnType<typeof Proof.prototype.toObject>;
                } = {};
                if (this.transactionBind != null) {
                    data.transactionBind = this.transactionBind.toObject();
                }
                if (this.proof != null) {
                    data.proof = this.proof.toObject();
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.has_transactionBind)
                    writer.writeMessage(1, this.transactionBind, () => this.transactionBind.serialize(writer));
                if (this.has_proof)
                    writer.writeMessage(2, this.proof, () => this.proof.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Not {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Not();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.transactionBind, () => message.transactionBind = dependency_1.quivr.models.TxBind.deserialize(reader));
                            break;
                        case 2:
                            reader.readMessage(message.proof, () => message.proof = Proof.deserialize(reader));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Not {
                return Not.deserialize(bytes);
            }
        }
        export class And extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                transactionBind?: dependency_1.quivr.models.TxBind;
                left?: Proof;
                right?: Proof;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("transactionBind" in data && data.transactionBind != undefined) {
                        this.transactionBind = data.transactionBind;
                    }
                    if ("left" in data && data.left != undefined) {
                        this.left = data.left;
                    }
                    if ("right" in data && data.right != undefined) {
                        this.right = data.right;
                    }
                }
            }
            get transactionBind() {
                return pb_1.Message.getWrapperField(this, dependency_1.quivr.models.TxBind, 1) as dependency_1.quivr.models.TxBind;
            }
            set transactionBind(value: dependency_1.quivr.models.TxBind) {
                pb_1.Message.setWrapperField(this, 1, value);
            }
            get has_transactionBind() {
                return pb_1.Message.getField(this, 1) != null;
            }
            get left() {
                return pb_1.Message.getWrapperField(this, Proof, 2) as Proof;
            }
            set left(value: Proof) {
                pb_1.Message.setWrapperField(this, 2, value);
            }
            get has_left() {
                return pb_1.Message.getField(this, 2) != null;
            }
            get right() {
                return pb_1.Message.getWrapperField(this, Proof, 3) as Proof;
            }
            set right(value: Proof) {
                pb_1.Message.setWrapperField(this, 3, value);
            }
            get has_right() {
                return pb_1.Message.getField(this, 3) != null;
            }
            static fromObject(data: {
                transactionBind?: ReturnType<typeof dependency_1.quivr.models.TxBind.prototype.toObject>;
                left?: ReturnType<typeof Proof.prototype.toObject>;
                right?: ReturnType<typeof Proof.prototype.toObject>;
            }): And {
                const message = new And({});
                if (data.transactionBind != null) {
                    message.transactionBind = dependency_1.quivr.models.TxBind.fromObject(data.transactionBind);
                }
                if (data.left != null) {
                    message.left = Proof.fromObject(data.left);
                }
                if (data.right != null) {
                    message.right = Proof.fromObject(data.right);
                }
                return message;
            }
            toObject() {
                const data: {
                    transactionBind?: ReturnType<typeof dependency_1.quivr.models.TxBind.prototype.toObject>;
                    left?: ReturnType<typeof Proof.prototype.toObject>;
                    right?: ReturnType<typeof Proof.prototype.toObject>;
                } = {};
                if (this.transactionBind != null) {
                    data.transactionBind = this.transactionBind.toObject();
                }
                if (this.left != null) {
                    data.left = this.left.toObject();
                }
                if (this.right != null) {
                    data.right = this.right.toObject();
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.has_transactionBind)
                    writer.writeMessage(1, this.transactionBind, () => this.transactionBind.serialize(writer));
                if (this.has_left)
                    writer.writeMessage(2, this.left, () => this.left.serialize(writer));
                if (this.has_right)
                    writer.writeMessage(3, this.right, () => this.right.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): And {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new And();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.transactionBind, () => message.transactionBind = dependency_1.quivr.models.TxBind.deserialize(reader));
                            break;
                        case 2:
                            reader.readMessage(message.left, () => message.left = Proof.deserialize(reader));
                            break;
                        case 3:
                            reader.readMessage(message.right, () => message.right = Proof.deserialize(reader));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): And {
                return And.deserialize(bytes);
            }
        }
        export class Or extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                transactionBind?: dependency_1.quivr.models.TxBind;
                left?: Proof;
                right?: Proof;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("transactionBind" in data && data.transactionBind != undefined) {
                        this.transactionBind = data.transactionBind;
                    }
                    if ("left" in data && data.left != undefined) {
                        this.left = data.left;
                    }
                    if ("right" in data && data.right != undefined) {
                        this.right = data.right;
                    }
                }
            }
            get transactionBind() {
                return pb_1.Message.getWrapperField(this, dependency_1.quivr.models.TxBind, 1) as dependency_1.quivr.models.TxBind;
            }
            set transactionBind(value: dependency_1.quivr.models.TxBind) {
                pb_1.Message.setWrapperField(this, 1, value);
            }
            get has_transactionBind() {
                return pb_1.Message.getField(this, 1) != null;
            }
            get left() {
                return pb_1.Message.getWrapperField(this, Proof, 2) as Proof;
            }
            set left(value: Proof) {
                pb_1.Message.setWrapperField(this, 2, value);
            }
            get has_left() {
                return pb_1.Message.getField(this, 2) != null;
            }
            get right() {
                return pb_1.Message.getWrapperField(this, Proof, 3) as Proof;
            }
            set right(value: Proof) {
                pb_1.Message.setWrapperField(this, 3, value);
            }
            get has_right() {
                return pb_1.Message.getField(this, 3) != null;
            }
            static fromObject(data: {
                transactionBind?: ReturnType<typeof dependency_1.quivr.models.TxBind.prototype.toObject>;
                left?: ReturnType<typeof Proof.prototype.toObject>;
                right?: ReturnType<typeof Proof.prototype.toObject>;
            }): Or {
                const message = new Or({});
                if (data.transactionBind != null) {
                    message.transactionBind = dependency_1.quivr.models.TxBind.fromObject(data.transactionBind);
                }
                if (data.left != null) {
                    message.left = Proof.fromObject(data.left);
                }
                if (data.right != null) {
                    message.right = Proof.fromObject(data.right);
                }
                return message;
            }
            toObject() {
                const data: {
                    transactionBind?: ReturnType<typeof dependency_1.quivr.models.TxBind.prototype.toObject>;
                    left?: ReturnType<typeof Proof.prototype.toObject>;
                    right?: ReturnType<typeof Proof.prototype.toObject>;
                } = {};
                if (this.transactionBind != null) {
                    data.transactionBind = this.transactionBind.toObject();
                }
                if (this.left != null) {
                    data.left = this.left.toObject();
                }
                if (this.right != null) {
                    data.right = this.right.toObject();
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.has_transactionBind)
                    writer.writeMessage(1, this.transactionBind, () => this.transactionBind.serialize(writer));
                if (this.has_left)
                    writer.writeMessage(2, this.left, () => this.left.serialize(writer));
                if (this.has_right)
                    writer.writeMessage(3, this.right, () => this.right.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Or {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Or();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.transactionBind, () => message.transactionBind = dependency_1.quivr.models.TxBind.deserialize(reader));
                            break;
                        case 2:
                            reader.readMessage(message.left, () => message.left = Proof.deserialize(reader));
                            break;
                        case 3:
                            reader.readMessage(message.right, () => message.right = Proof.deserialize(reader));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Or {
                return Or.deserialize(bytes);
            }
        }
    }
}
