/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.6.1
 * source: genus/genus_models.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./../brambl/models/address";
import * as dependency_2 from "./../brambl/models/transaction/io_transaction";
import * as dependency_3 from "./../brambl/models/transaction/unspent_transaction_output";
import * as dependency_4 from "./../consensus/models/block_id";
import * as dependency_5 from "./../consensus/models/block_header";
import * as dependency_6 from "./../node/models/block";
import * as dependency_7 from "./../google/protobuf/wrappers";
import * as dependency_8 from "./../validate/validate";
import * as pb_1 from "google-protobuf";
export namespace co.topl.genus.services {
    export enum TxoState {
        SPENT = 0,
        UNSPENT = 1,
        PENDING = 2
    }
    export enum SortOrder {
        ASCENDING = 0,
        DESCENDING = 1,
        UNSORTED = 2
    }
    export enum LabelType {
        EMPTY = 0,
        LVL = 1,
        TOPL = 2,
        V1 = 3,
        TAM2 = 4
    }
    export class Txo extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            transactionOutput?: dependency_3.co.topl.brambl.models.transaction.UnspentTransactionOutput;
            state?: TxoState;
            outputAddress?: dependency_1.co.topl.brambl.models.TransactionOutputAddress;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("transactionOutput" in data && data.transactionOutput != undefined) {
                    this.transactionOutput = data.transactionOutput;
                }
                if ("state" in data && data.state != undefined) {
                    this.state = data.state;
                }
                if ("outputAddress" in data && data.outputAddress != undefined) {
                    this.outputAddress = data.outputAddress;
                }
            }
        }
        get transactionOutput() {
            return pb_1.Message.getWrapperField(this, dependency_3.co.topl.brambl.models.transaction.UnspentTransactionOutput, 1) as dependency_3.co.topl.brambl.models.transaction.UnspentTransactionOutput;
        }
        set transactionOutput(value: dependency_3.co.topl.brambl.models.transaction.UnspentTransactionOutput) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_transactionOutput() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get state() {
            return pb_1.Message.getFieldWithDefault(this, 2, TxoState.SPENT) as TxoState;
        }
        set state(value: TxoState) {
            pb_1.Message.setField(this, 2, value);
        }
        get outputAddress() {
            return pb_1.Message.getWrapperField(this, dependency_1.co.topl.brambl.models.TransactionOutputAddress, 3) as dependency_1.co.topl.brambl.models.TransactionOutputAddress;
        }
        set outputAddress(value: dependency_1.co.topl.brambl.models.TransactionOutputAddress) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_outputAddress() {
            return pb_1.Message.getField(this, 3) != null;
        }
        static fromObject(data: {
            transactionOutput?: ReturnType<typeof dependency_3.co.topl.brambl.models.transaction.UnspentTransactionOutput.prototype.toObject>;
            state?: TxoState;
            outputAddress?: ReturnType<typeof dependency_1.co.topl.brambl.models.TransactionOutputAddress.prototype.toObject>;
        }): Txo {
            const message = new Txo({});
            if (data.transactionOutput != null) {
                message.transactionOutput = dependency_3.co.topl.brambl.models.transaction.UnspentTransactionOutput.fromObject(data.transactionOutput);
            }
            if (data.state != null) {
                message.state = data.state;
            }
            if (data.outputAddress != null) {
                message.outputAddress = dependency_1.co.topl.brambl.models.TransactionOutputAddress.fromObject(data.outputAddress);
            }
            return message;
        }
        toObject() {
            const data: {
                transactionOutput?: ReturnType<typeof dependency_3.co.topl.brambl.models.transaction.UnspentTransactionOutput.prototype.toObject>;
                state?: TxoState;
                outputAddress?: ReturnType<typeof dependency_1.co.topl.brambl.models.TransactionOutputAddress.prototype.toObject>;
            } = {};
            if (this.transactionOutput != null) {
                data.transactionOutput = this.transactionOutput.toObject();
            }
            if (this.state != null) {
                data.state = this.state;
            }
            if (this.outputAddress != null) {
                data.outputAddress = this.outputAddress.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_transactionOutput)
                writer.writeMessage(1, this.transactionOutput, () => this.transactionOutput.serialize(writer));
            if (this.state != TxoState.SPENT)
                writer.writeEnum(2, this.state);
            if (this.has_outputAddress)
                writer.writeMessage(3, this.outputAddress, () => this.outputAddress.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Txo {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Txo();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.transactionOutput, () => message.transactionOutput = dependency_3.co.topl.brambl.models.transaction.UnspentTransactionOutput.deserialize(reader));
                        break;
                    case 2:
                        message.state = reader.readEnum();
                        break;
                    case 3:
                        reader.readMessage(message.outputAddress, () => message.outputAddress = dependency_1.co.topl.brambl.models.TransactionOutputAddress.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Txo {
            return Txo.deserialize(bytes);
        }
    }
    export class ConfidenceFactor extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            value?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
            }
        }
        get value() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set value(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            value?: number;
        }): ConfidenceFactor {
            const message = new ConfidenceFactor({});
            if (data.value != null) {
                message.value = data.value;
            }
            return message;
        }
        toObject() {
            const data: {
                value?: number;
            } = {};
            if (this.value != null) {
                data.value = this.value;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.value != 0)
                writer.writeDouble(1, this.value);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ConfidenceFactor {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ConfidenceFactor();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.value = reader.readDouble();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ConfidenceFactor {
            return ConfidenceFactor.deserialize(bytes);
        }
    }
    export class ChainDistance extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            value?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
            }
        }
        get value() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set value(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            value?: number;
        }): ChainDistance {
            const message = new ChainDistance({});
            if (data.value != null) {
                message.value = data.value;
            }
            return message;
        }
        toObject() {
            const data: {
                value?: number;
            } = {};
            if (this.value != null) {
                data.value = this.value;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.value != 0)
                writer.writeInt64(1, this.value);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ChainDistance {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ChainDistance();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.value = reader.readInt64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ChainDistance {
            return ChainDistance.deserialize(bytes);
        }
    }
    export class AssetLabel extends pb_1.Message {
        #one_of_decls: number[][] = [[2, 3, 4]];
        constructor(data?: any[] | ({
            labelType?: LabelType;
        } & (({
            empty?: AssetLabel.Empty;
            v1Label?: never;
            tam2Label?: never;
        } | {
            empty?: never;
            v1Label?: AssetLabel.V1Label;
            tam2Label?: never;
        } | {
            empty?: never;
            v1Label?: never;
            tam2Label?: AssetLabel.Tam2Label;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("labelType" in data && data.labelType != undefined) {
                    this.labelType = data.labelType;
                }
                if ("empty" in data && data.empty != undefined) {
                    this.empty = data.empty;
                }
                if ("v1Label" in data && data.v1Label != undefined) {
                    this.v1Label = data.v1Label;
                }
                if ("tam2Label" in data && data.tam2Label != undefined) {
                    this.tam2Label = data.tam2Label;
                }
            }
        }
        get labelType() {
            return pb_1.Message.getFieldWithDefault(this, 1, LabelType.EMPTY) as LabelType;
        }
        set labelType(value: LabelType) {
            pb_1.Message.setField(this, 1, value);
        }
        get empty() {
            return pb_1.Message.getWrapperField(this, AssetLabel.Empty, 2) as AssetLabel.Empty;
        }
        set empty(value: AssetLabel.Empty) {
            pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
        }
        get has_empty() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get v1Label() {
            return pb_1.Message.getWrapperField(this, AssetLabel.V1Label, 3) as AssetLabel.V1Label;
        }
        set v1Label(value: AssetLabel.V1Label) {
            pb_1.Message.setOneofWrapperField(this, 3, this.#one_of_decls[0], value);
        }
        get has_v1Label() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get tam2Label() {
            return pb_1.Message.getWrapperField(this, AssetLabel.Tam2Label, 4) as AssetLabel.Tam2Label;
        }
        set tam2Label(value: AssetLabel.Tam2Label) {
            pb_1.Message.setOneofWrapperField(this, 4, this.#one_of_decls[0], value);
        }
        get has_tam2Label() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get label() {
            const cases: {
                [index: number]: "none" | "empty" | "v1Label" | "tam2Label";
            } = {
                0: "none",
                2: "empty",
                3: "v1Label",
                4: "tam2Label"
            };
            return cases[pb_1.Message.computeOneofCase(this, [2, 3, 4])];
        }
        static fromObject(data: {
            labelType?: LabelType;
            empty?: ReturnType<typeof AssetLabel.Empty.prototype.toObject>;
            v1Label?: ReturnType<typeof AssetLabel.V1Label.prototype.toObject>;
            tam2Label?: ReturnType<typeof AssetLabel.Tam2Label.prototype.toObject>;
        }): AssetLabel {
            const message = new AssetLabel({});
            if (data.labelType != null) {
                message.labelType = data.labelType;
            }
            if (data.empty != null) {
                message.empty = AssetLabel.Empty.fromObject(data.empty);
            }
            if (data.v1Label != null) {
                message.v1Label = AssetLabel.V1Label.fromObject(data.v1Label);
            }
            if (data.tam2Label != null) {
                message.tam2Label = AssetLabel.Tam2Label.fromObject(data.tam2Label);
            }
            return message;
        }
        toObject() {
            const data: {
                labelType?: LabelType;
                empty?: ReturnType<typeof AssetLabel.Empty.prototype.toObject>;
                v1Label?: ReturnType<typeof AssetLabel.V1Label.prototype.toObject>;
                tam2Label?: ReturnType<typeof AssetLabel.Tam2Label.prototype.toObject>;
            } = {};
            if (this.labelType != null) {
                data.labelType = this.labelType;
            }
            if (this.empty != null) {
                data.empty = this.empty.toObject();
            }
            if (this.v1Label != null) {
                data.v1Label = this.v1Label.toObject();
            }
            if (this.tam2Label != null) {
                data.tam2Label = this.tam2Label.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.labelType != LabelType.EMPTY)
                writer.writeEnum(1, this.labelType);
            if (this.has_empty)
                writer.writeMessage(2, this.empty, () => this.empty.serialize(writer));
            if (this.has_v1Label)
                writer.writeMessage(3, this.v1Label, () => this.v1Label.serialize(writer));
            if (this.has_tam2Label)
                writer.writeMessage(4, this.tam2Label, () => this.tam2Label.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AssetLabel {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new AssetLabel();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.labelType = reader.readEnum();
                        break;
                    case 2:
                        reader.readMessage(message.empty, () => message.empty = AssetLabel.Empty.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.v1Label, () => message.v1Label = AssetLabel.V1Label.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.tam2Label, () => message.tam2Label = AssetLabel.Tam2Label.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): AssetLabel {
            return AssetLabel.deserialize(bytes);
        }
    }
    export namespace AssetLabel {
        export class Empty extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {}) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") { }
            }
            static fromObject(data: {}): Empty {
                const message = new Empty({});
                return message;
            }
            toObject() {
                const data: {} = {};
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Empty {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Empty();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Empty {
                return Empty.deserialize(bytes);
            }
        }
        export class V1Label extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                version?: number;
                mintingAddress?: dependency_1.co.topl.brambl.models.LockAddress;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("version" in data && data.version != undefined) {
                        this.version = data.version;
                    }
                    if ("mintingAddress" in data && data.mintingAddress != undefined) {
                        this.mintingAddress = data.mintingAddress;
                    }
                }
            }
            get version() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set version(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get mintingAddress() {
                return pb_1.Message.getWrapperField(this, dependency_1.co.topl.brambl.models.LockAddress, 2) as dependency_1.co.topl.brambl.models.LockAddress;
            }
            set mintingAddress(value: dependency_1.co.topl.brambl.models.LockAddress) {
                pb_1.Message.setWrapperField(this, 2, value);
            }
            get has_mintingAddress() {
                return pb_1.Message.getField(this, 2) != null;
            }
            static fromObject(data: {
                version?: number;
                mintingAddress?: ReturnType<typeof dependency_1.co.topl.brambl.models.LockAddress.prototype.toObject>;
            }): V1Label {
                const message = new V1Label({});
                if (data.version != null) {
                    message.version = data.version;
                }
                if (data.mintingAddress != null) {
                    message.mintingAddress = dependency_1.co.topl.brambl.models.LockAddress.fromObject(data.mintingAddress);
                }
                return message;
            }
            toObject() {
                const data: {
                    version?: number;
                    mintingAddress?: ReturnType<typeof dependency_1.co.topl.brambl.models.LockAddress.prototype.toObject>;
                } = {};
                if (this.version != null) {
                    data.version = this.version;
                }
                if (this.mintingAddress != null) {
                    data.mintingAddress = this.mintingAddress.toObject();
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.version != 0)
                    writer.writeUint32(1, this.version);
                if (this.has_mintingAddress)
                    writer.writeMessage(2, this.mintingAddress, () => this.mintingAddress.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): V1Label {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new V1Label();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.version = reader.readUint32();
                            break;
                        case 2:
                            reader.readMessage(message.mintingAddress, () => message.mintingAddress = dependency_1.co.topl.brambl.models.LockAddress.deserialize(reader));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): V1Label {
                return V1Label.deserialize(bytes);
            }
        }
        export class Tam2Label extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                groupHashMostSignificant?: number;
                groupHashMoreSignificant?: number;
                groupHashLessSignificant?: number;
                groupHashLeastSignificant?: number;
                seriesHashMostSignificant?: number;
                seriesHashMoreSignificant?: number;
                seriesHashLessSignificant?: number;
                seriesHashLeastSignificant?: number;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("groupHashMostSignificant" in data && data.groupHashMostSignificant != undefined) {
                        this.groupHashMostSignificant = data.groupHashMostSignificant;
                    }
                    if ("groupHashMoreSignificant" in data && data.groupHashMoreSignificant != undefined) {
                        this.groupHashMoreSignificant = data.groupHashMoreSignificant;
                    }
                    if ("groupHashLessSignificant" in data && data.groupHashLessSignificant != undefined) {
                        this.groupHashLessSignificant = data.groupHashLessSignificant;
                    }
                    if ("groupHashLeastSignificant" in data && data.groupHashLeastSignificant != undefined) {
                        this.groupHashLeastSignificant = data.groupHashLeastSignificant;
                    }
                    if ("seriesHashMostSignificant" in data && data.seriesHashMostSignificant != undefined) {
                        this.seriesHashMostSignificant = data.seriesHashMostSignificant;
                    }
                    if ("seriesHashMoreSignificant" in data && data.seriesHashMoreSignificant != undefined) {
                        this.seriesHashMoreSignificant = data.seriesHashMoreSignificant;
                    }
                    if ("seriesHashLessSignificant" in data && data.seriesHashLessSignificant != undefined) {
                        this.seriesHashLessSignificant = data.seriesHashLessSignificant;
                    }
                    if ("seriesHashLeastSignificant" in data && data.seriesHashLeastSignificant != undefined) {
                        this.seriesHashLeastSignificant = data.seriesHashLeastSignificant;
                    }
                }
            }
            get groupHashMostSignificant() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set groupHashMostSignificant(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get groupHashMoreSignificant() {
                return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
            }
            set groupHashMoreSignificant(value: number) {
                pb_1.Message.setField(this, 2, value);
            }
            get groupHashLessSignificant() {
                return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
            }
            set groupHashLessSignificant(value: number) {
                pb_1.Message.setField(this, 3, value);
            }
            get groupHashLeastSignificant() {
                return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
            }
            set groupHashLeastSignificant(value: number) {
                pb_1.Message.setField(this, 4, value);
            }
            get seriesHashMostSignificant() {
                return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
            }
            set seriesHashMostSignificant(value: number) {
                pb_1.Message.setField(this, 5, value);
            }
            get seriesHashMoreSignificant() {
                return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
            }
            set seriesHashMoreSignificant(value: number) {
                pb_1.Message.setField(this, 6, value);
            }
            get seriesHashLessSignificant() {
                return pb_1.Message.getFieldWithDefault(this, 7, 0) as number;
            }
            set seriesHashLessSignificant(value: number) {
                pb_1.Message.setField(this, 7, value);
            }
            get seriesHashLeastSignificant() {
                return pb_1.Message.getFieldWithDefault(this, 8, 0) as number;
            }
            set seriesHashLeastSignificant(value: number) {
                pb_1.Message.setField(this, 8, value);
            }
            static fromObject(data: {
                groupHashMostSignificant?: number;
                groupHashMoreSignificant?: number;
                groupHashLessSignificant?: number;
                groupHashLeastSignificant?: number;
                seriesHashMostSignificant?: number;
                seriesHashMoreSignificant?: number;
                seriesHashLessSignificant?: number;
                seriesHashLeastSignificant?: number;
            }): Tam2Label {
                const message = new Tam2Label({});
                if (data.groupHashMostSignificant != null) {
                    message.groupHashMostSignificant = data.groupHashMostSignificant;
                }
                if (data.groupHashMoreSignificant != null) {
                    message.groupHashMoreSignificant = data.groupHashMoreSignificant;
                }
                if (data.groupHashLessSignificant != null) {
                    message.groupHashLessSignificant = data.groupHashLessSignificant;
                }
                if (data.groupHashLeastSignificant != null) {
                    message.groupHashLeastSignificant = data.groupHashLeastSignificant;
                }
                if (data.seriesHashMostSignificant != null) {
                    message.seriesHashMostSignificant = data.seriesHashMostSignificant;
                }
                if (data.seriesHashMoreSignificant != null) {
                    message.seriesHashMoreSignificant = data.seriesHashMoreSignificant;
                }
                if (data.seriesHashLessSignificant != null) {
                    message.seriesHashLessSignificant = data.seriesHashLessSignificant;
                }
                if (data.seriesHashLeastSignificant != null) {
                    message.seriesHashLeastSignificant = data.seriesHashLeastSignificant;
                }
                return message;
            }
            toObject() {
                const data: {
                    groupHashMostSignificant?: number;
                    groupHashMoreSignificant?: number;
                    groupHashLessSignificant?: number;
                    groupHashLeastSignificant?: number;
                    seriesHashMostSignificant?: number;
                    seriesHashMoreSignificant?: number;
                    seriesHashLessSignificant?: number;
                    seriesHashLeastSignificant?: number;
                } = {};
                if (this.groupHashMostSignificant != null) {
                    data.groupHashMostSignificant = this.groupHashMostSignificant;
                }
                if (this.groupHashMoreSignificant != null) {
                    data.groupHashMoreSignificant = this.groupHashMoreSignificant;
                }
                if (this.groupHashLessSignificant != null) {
                    data.groupHashLessSignificant = this.groupHashLessSignificant;
                }
                if (this.groupHashLeastSignificant != null) {
                    data.groupHashLeastSignificant = this.groupHashLeastSignificant;
                }
                if (this.seriesHashMostSignificant != null) {
                    data.seriesHashMostSignificant = this.seriesHashMostSignificant;
                }
                if (this.seriesHashMoreSignificant != null) {
                    data.seriesHashMoreSignificant = this.seriesHashMoreSignificant;
                }
                if (this.seriesHashLessSignificant != null) {
                    data.seriesHashLessSignificant = this.seriesHashLessSignificant;
                }
                if (this.seriesHashLeastSignificant != null) {
                    data.seriesHashLeastSignificant = this.seriesHashLeastSignificant;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.groupHashMostSignificant != 0)
                    writer.writeFixed64(1, this.groupHashMostSignificant);
                if (this.groupHashMoreSignificant != 0)
                    writer.writeFixed64(2, this.groupHashMoreSignificant);
                if (this.groupHashLessSignificant != 0)
                    writer.writeFixed64(3, this.groupHashLessSignificant);
                if (this.groupHashLeastSignificant != 0)
                    writer.writeFixed64(4, this.groupHashLeastSignificant);
                if (this.seriesHashMostSignificant != 0)
                    writer.writeFixed64(5, this.seriesHashMostSignificant);
                if (this.seriesHashMoreSignificant != 0)
                    writer.writeFixed64(6, this.seriesHashMoreSignificant);
                if (this.seriesHashLessSignificant != 0)
                    writer.writeFixed64(7, this.seriesHashLessSignificant);
                if (this.seriesHashLeastSignificant != 0)
                    writer.writeFixed64(8, this.seriesHashLeastSignificant);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Tam2Label {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Tam2Label();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.groupHashMostSignificant = reader.readFixed64();
                            break;
                        case 2:
                            message.groupHashMoreSignificant = reader.readFixed64();
                            break;
                        case 3:
                            message.groupHashLessSignificant = reader.readFixed64();
                            break;
                        case 4:
                            message.groupHashLeastSignificant = reader.readFixed64();
                            break;
                        case 5:
                            message.seriesHashMostSignificant = reader.readFixed64();
                            break;
                        case 6:
                            message.seriesHashMoreSignificant = reader.readFixed64();
                            break;
                        case 7:
                            message.seriesHashLessSignificant = reader.readFixed64();
                            break;
                        case 8:
                            message.seriesHashLeastSignificant = reader.readFixed64();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Tam2Label {
                return Tam2Label.deserialize(bytes);
            }
        }
    }
    export class IndexSpec extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            indexName?: string;
            indexFieldSpec?: IndexFieldSpec;
            indexFilter?: IndexFilter;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("indexName" in data && data.indexName != undefined) {
                    this.indexName = data.indexName;
                }
                if ("indexFieldSpec" in data && data.indexFieldSpec != undefined) {
                    this.indexFieldSpec = data.indexFieldSpec;
                }
                if ("indexFilter" in data && data.indexFilter != undefined) {
                    this.indexFilter = data.indexFilter;
                }
            }
        }
        get indexName() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set indexName(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get indexFieldSpec() {
            return pb_1.Message.getWrapperField(this, IndexFieldSpec, 2) as IndexFieldSpec;
        }
        set indexFieldSpec(value: IndexFieldSpec) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_indexFieldSpec() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get indexFilter() {
            return pb_1.Message.getWrapperField(this, IndexFilter, 3) as IndexFilter;
        }
        set indexFilter(value: IndexFilter) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_indexFilter() {
            return pb_1.Message.getField(this, 3) != null;
        }
        static fromObject(data: {
            indexName?: string;
            indexFieldSpec?: ReturnType<typeof IndexFieldSpec.prototype.toObject>;
            indexFilter?: ReturnType<typeof IndexFilter.prototype.toObject>;
        }): IndexSpec {
            const message = new IndexSpec({});
            if (data.indexName != null) {
                message.indexName = data.indexName;
            }
            if (data.indexFieldSpec != null) {
                message.indexFieldSpec = IndexFieldSpec.fromObject(data.indexFieldSpec);
            }
            if (data.indexFilter != null) {
                message.indexFilter = IndexFilter.fromObject(data.indexFilter);
            }
            return message;
        }
        toObject() {
            const data: {
                indexName?: string;
                indexFieldSpec?: ReturnType<typeof IndexFieldSpec.prototype.toObject>;
                indexFilter?: ReturnType<typeof IndexFilter.prototype.toObject>;
            } = {};
            if (this.indexName != null) {
                data.indexName = this.indexName;
            }
            if (this.indexFieldSpec != null) {
                data.indexFieldSpec = this.indexFieldSpec.toObject();
            }
            if (this.indexFilter != null) {
                data.indexFilter = this.indexFilter.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.indexName.length)
                writer.writeString(1, this.indexName);
            if (this.has_indexFieldSpec)
                writer.writeMessage(2, this.indexFieldSpec, () => this.indexFieldSpec.serialize(writer));
            if (this.has_indexFilter)
                writer.writeMessage(3, this.indexFilter, () => this.indexFilter.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): IndexSpec {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new IndexSpec();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.indexName = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.indexFieldSpec, () => message.indexFieldSpec = IndexFieldSpec.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.indexFilter, () => message.indexFilter = IndexFilter.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): IndexSpec {
            return IndexSpec.deserialize(bytes);
        }
    }
    export class IndexFieldSpec extends pb_1.Message {
        #one_of_decls: number[][] = [[1, 2]];
        constructor(data?: any[] | ({} & (({
            jsonSpecs?: JsonIndexSpecs;
            csvSpecs?: never;
        } | {
            jsonSpecs?: never;
            csvSpecs?: CsvIndexSpecs;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("jsonSpecs" in data && data.jsonSpecs != undefined) {
                    this.jsonSpecs = data.jsonSpecs;
                }
                if ("csvSpecs" in data && data.csvSpecs != undefined) {
                    this.csvSpecs = data.csvSpecs;
                }
            }
        }
        get jsonSpecs() {
            return pb_1.Message.getWrapperField(this, JsonIndexSpecs, 1) as JsonIndexSpecs;
        }
        set jsonSpecs(value: JsonIndexSpecs) {
            pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
        }
        get has_jsonSpecs() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get csvSpecs() {
            return pb_1.Message.getWrapperField(this, CsvIndexSpecs, 2) as CsvIndexSpecs;
        }
        set csvSpecs(value: CsvIndexSpecs) {
            pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
        }
        get has_csvSpecs() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get spec() {
            const cases: {
                [index: number]: "none" | "jsonSpecs" | "csvSpecs";
            } = {
                0: "none",
                1: "jsonSpecs",
                2: "csvSpecs"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1, 2])];
        }
        static fromObject(data: {
            jsonSpecs?: ReturnType<typeof JsonIndexSpecs.prototype.toObject>;
            csvSpecs?: ReturnType<typeof CsvIndexSpecs.prototype.toObject>;
        }): IndexFieldSpec {
            const message = new IndexFieldSpec({});
            if (data.jsonSpecs != null) {
                message.jsonSpecs = JsonIndexSpecs.fromObject(data.jsonSpecs);
            }
            if (data.csvSpecs != null) {
                message.csvSpecs = CsvIndexSpecs.fromObject(data.csvSpecs);
            }
            return message;
        }
        toObject() {
            const data: {
                jsonSpecs?: ReturnType<typeof JsonIndexSpecs.prototype.toObject>;
                csvSpecs?: ReturnType<typeof CsvIndexSpecs.prototype.toObject>;
            } = {};
            if (this.jsonSpecs != null) {
                data.jsonSpecs = this.jsonSpecs.toObject();
            }
            if (this.csvSpecs != null) {
                data.csvSpecs = this.csvSpecs.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_jsonSpecs)
                writer.writeMessage(1, this.jsonSpecs, () => this.jsonSpecs.serialize(writer));
            if (this.has_csvSpecs)
                writer.writeMessage(2, this.csvSpecs, () => this.csvSpecs.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): IndexFieldSpec {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new IndexFieldSpec();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.jsonSpecs, () => message.jsonSpecs = JsonIndexSpecs.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.csvSpecs, () => message.csvSpecs = CsvIndexSpecs.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): IndexFieldSpec {
            return IndexFieldSpec.deserialize(bytes);
        }
    }
    export class CsvIndexSpecs extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            specs?: CsvIndexSpec[];
            separatorChar?: number;
            quoteChar?: dependency_7.google.protobuf.UInt32Value;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("specs" in data && data.specs != undefined) {
                    this.specs = data.specs;
                }
                if ("separatorChar" in data && data.separatorChar != undefined) {
                    this.separatorChar = data.separatorChar;
                }
                if ("quoteChar" in data && data.quoteChar != undefined) {
                    this.quoteChar = data.quoteChar;
                }
            }
        }
        get specs() {
            return pb_1.Message.getRepeatedWrapperField(this, CsvIndexSpec, 1) as CsvIndexSpec[];
        }
        set specs(value: CsvIndexSpec[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get separatorChar() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set separatorChar(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get quoteChar() {
            return pb_1.Message.getWrapperField(this, dependency_7.google.protobuf.UInt32Value, 3) as dependency_7.google.protobuf.UInt32Value;
        }
        set quoteChar(value: dependency_7.google.protobuf.UInt32Value) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_quoteChar() {
            return pb_1.Message.getField(this, 3) != null;
        }
        static fromObject(data: {
            specs?: ReturnType<typeof CsvIndexSpec.prototype.toObject>[];
            separatorChar?: number;
            quoteChar?: ReturnType<typeof dependency_7.google.protobuf.UInt32Value.prototype.toObject>;
        }): CsvIndexSpecs {
            const message = new CsvIndexSpecs({});
            if (data.specs != null) {
                message.specs = data.specs.map(item => CsvIndexSpec.fromObject(item));
            }
            if (data.separatorChar != null) {
                message.separatorChar = data.separatorChar;
            }
            if (data.quoteChar != null) {
                message.quoteChar = dependency_7.google.protobuf.UInt32Value.fromObject(data.quoteChar);
            }
            return message;
        }
        toObject() {
            const data: {
                specs?: ReturnType<typeof CsvIndexSpec.prototype.toObject>[];
                separatorChar?: number;
                quoteChar?: ReturnType<typeof dependency_7.google.protobuf.UInt32Value.prototype.toObject>;
            } = {};
            if (this.specs != null) {
                data.specs = this.specs.map((item: CsvIndexSpec) => item.toObject());
            }
            if (this.separatorChar != null) {
                data.separatorChar = this.separatorChar;
            }
            if (this.quoteChar != null) {
                data.quoteChar = this.quoteChar.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.specs.length)
                writer.writeRepeatedMessage(1, this.specs, (item: CsvIndexSpec) => item.serialize(writer));
            if (this.separatorChar != 0)
                writer.writeUint32(2, this.separatorChar);
            if (this.has_quoteChar)
                writer.writeMessage(3, this.quoteChar, () => this.quoteChar.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CsvIndexSpecs {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CsvIndexSpecs();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.specs, () => pb_1.Message.addToRepeatedWrapperField(message, 1, CsvIndexSpec.deserialize(reader), CsvIndexSpec));
                        break;
                    case 2:
                        message.separatorChar = reader.readUint32();
                        break;
                    case 3:
                        reader.readMessage(message.quoteChar, () => message.quoteChar = dependency_7.google.protobuf.UInt32Value.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CsvIndexSpecs {
            return CsvIndexSpecs.deserialize(bytes);
        }
    }
    export class CsvIndexSpec extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            fieldIndex?: number;
            sortOrder?: SortOrder;
            isNumeric?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("fieldIndex" in data && data.fieldIndex != undefined) {
                    this.fieldIndex = data.fieldIndex;
                }
                if ("sortOrder" in data && data.sortOrder != undefined) {
                    this.sortOrder = data.sortOrder;
                }
                if ("isNumeric" in data && data.isNumeric != undefined) {
                    this.isNumeric = data.isNumeric;
                }
            }
        }
        get fieldIndex() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set fieldIndex(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get sortOrder() {
            return pb_1.Message.getFieldWithDefault(this, 2, SortOrder.ASCENDING) as SortOrder;
        }
        set sortOrder(value: SortOrder) {
            pb_1.Message.setField(this, 2, value);
        }
        get isNumeric() {
            return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
        }
        set isNumeric(value: boolean) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            fieldIndex?: number;
            sortOrder?: SortOrder;
            isNumeric?: boolean;
        }): CsvIndexSpec {
            const message = new CsvIndexSpec({});
            if (data.fieldIndex != null) {
                message.fieldIndex = data.fieldIndex;
            }
            if (data.sortOrder != null) {
                message.sortOrder = data.sortOrder;
            }
            if (data.isNumeric != null) {
                message.isNumeric = data.isNumeric;
            }
            return message;
        }
        toObject() {
            const data: {
                fieldIndex?: number;
                sortOrder?: SortOrder;
                isNumeric?: boolean;
            } = {};
            if (this.fieldIndex != null) {
                data.fieldIndex = this.fieldIndex;
            }
            if (this.sortOrder != null) {
                data.sortOrder = this.sortOrder;
            }
            if (this.isNumeric != null) {
                data.isNumeric = this.isNumeric;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.fieldIndex != 0)
                writer.writeUint32(1, this.fieldIndex);
            if (this.sortOrder != SortOrder.ASCENDING)
                writer.writeEnum(2, this.sortOrder);
            if (this.isNumeric != false)
                writer.writeBool(3, this.isNumeric);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CsvIndexSpec {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CsvIndexSpec();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.fieldIndex = reader.readUint32();
                        break;
                    case 2:
                        message.sortOrder = reader.readEnum();
                        break;
                    case 3:
                        message.isNumeric = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CsvIndexSpec {
            return CsvIndexSpec.deserialize(bytes);
        }
    }
    export class JsonIndexSpecs extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            specs?: JsonIndexSpec[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("specs" in data && data.specs != undefined) {
                    this.specs = data.specs;
                }
            }
        }
        get specs() {
            return pb_1.Message.getRepeatedWrapperField(this, JsonIndexSpec, 1) as JsonIndexSpec[];
        }
        set specs(value: JsonIndexSpec[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            specs?: ReturnType<typeof JsonIndexSpec.prototype.toObject>[];
        }): JsonIndexSpecs {
            const message = new JsonIndexSpecs({});
            if (data.specs != null) {
                message.specs = data.specs.map(item => JsonIndexSpec.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                specs?: ReturnType<typeof JsonIndexSpec.prototype.toObject>[];
            } = {};
            if (this.specs != null) {
                data.specs = this.specs.map((item: JsonIndexSpec) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.specs.length)
                writer.writeRepeatedMessage(1, this.specs, (item: JsonIndexSpec) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): JsonIndexSpecs {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new JsonIndexSpecs();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.specs, () => pb_1.Message.addToRepeatedWrapperField(message, 1, JsonIndexSpec.deserialize(reader), JsonIndexSpec));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): JsonIndexSpecs {
            return JsonIndexSpecs.deserialize(bytes);
        }
    }
    export class JsonIndexSpec extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            jsonPath?: string;
            sortOrder?: SortOrder;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("jsonPath" in data && data.jsonPath != undefined) {
                    this.jsonPath = data.jsonPath;
                }
                if ("sortOrder" in data && data.sortOrder != undefined) {
                    this.sortOrder = data.sortOrder;
                }
            }
        }
        get jsonPath() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set jsonPath(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get sortOrder() {
            return pb_1.Message.getFieldWithDefault(this, 2, SortOrder.ASCENDING) as SortOrder;
        }
        set sortOrder(value: SortOrder) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            jsonPath?: string;
            sortOrder?: SortOrder;
        }): JsonIndexSpec {
            const message = new JsonIndexSpec({});
            if (data.jsonPath != null) {
                message.jsonPath = data.jsonPath;
            }
            if (data.sortOrder != null) {
                message.sortOrder = data.sortOrder;
            }
            return message;
        }
        toObject() {
            const data: {
                jsonPath?: string;
                sortOrder?: SortOrder;
            } = {};
            if (this.jsonPath != null) {
                data.jsonPath = this.jsonPath;
            }
            if (this.sortOrder != null) {
                data.sortOrder = this.sortOrder;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.jsonPath.length)
                writer.writeString(1, this.jsonPath);
            if (this.sortOrder != SortOrder.ASCENDING)
                writer.writeEnum(2, this.sortOrder);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): JsonIndexSpec {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new JsonIndexSpec();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.jsonPath = reader.readString();
                        break;
                    case 2:
                        message.sortOrder = reader.readEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): JsonIndexSpec {
            return JsonIndexSpec.deserialize(bytes);
        }
    }
    export class IndexFilter extends pb_1.Message {
        #one_of_decls: number[][] = [[1]];
        constructor(data?: any[] | ({} & (({
            regexIndexFilter?: string;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("regexIndexFilter" in data && data.regexIndexFilter != undefined) {
                    this.regexIndexFilter = data.regexIndexFilter;
                }
            }
        }
        get regexIndexFilter() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set regexIndexFilter(value: string) {
            pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
        }
        get has_regexIndexFilter() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get filter() {
            const cases: {
                [index: number]: "none" | "regexIndexFilter";
            } = {
                0: "none",
                1: "regexIndexFilter"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1])];
        }
        static fromObject(data: {
            regexIndexFilter?: string;
        }): IndexFilter {
            const message = new IndexFilter({});
            if (data.regexIndexFilter != null) {
                message.regexIndexFilter = data.regexIndexFilter;
            }
            return message;
        }
        toObject() {
            const data: {
                regexIndexFilter?: string;
            } = {};
            if (this.regexIndexFilter != null) {
                data.regexIndexFilter = this.regexIndexFilter;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_regexIndexFilter)
                writer.writeString(1, this.regexIndexFilter);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): IndexFilter {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new IndexFilter();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.regexIndexFilter = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): IndexFilter {
            return IndexFilter.deserialize(bytes);
        }
    }
    export class TransactionReceipt extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            transaction?: dependency_2.co.topl.brambl.models.transaction.IoTransaction;
            confidenceFactor?: ConfidenceFactor;
            blockId?: dependency_4.co.topl.consensus.models.BlockId;
            depth?: ChainDistance;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("transaction" in data && data.transaction != undefined) {
                    this.transaction = data.transaction;
                }
                if ("confidenceFactor" in data && data.confidenceFactor != undefined) {
                    this.confidenceFactor = data.confidenceFactor;
                }
                if ("blockId" in data && data.blockId != undefined) {
                    this.blockId = data.blockId;
                }
                if ("depth" in data && data.depth != undefined) {
                    this.depth = data.depth;
                }
            }
        }
        get transaction() {
            return pb_1.Message.getWrapperField(this, dependency_2.co.topl.brambl.models.transaction.IoTransaction, 1) as dependency_2.co.topl.brambl.models.transaction.IoTransaction;
        }
        set transaction(value: dependency_2.co.topl.brambl.models.transaction.IoTransaction) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_transaction() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get confidenceFactor() {
            return pb_1.Message.getWrapperField(this, ConfidenceFactor, 2) as ConfidenceFactor;
        }
        set confidenceFactor(value: ConfidenceFactor) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_confidenceFactor() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get blockId() {
            return pb_1.Message.getWrapperField(this, dependency_4.co.topl.consensus.models.BlockId, 3) as dependency_4.co.topl.consensus.models.BlockId;
        }
        set blockId(value: dependency_4.co.topl.consensus.models.BlockId) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_blockId() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get depth() {
            return pb_1.Message.getWrapperField(this, ChainDistance, 4) as ChainDistance;
        }
        set depth(value: ChainDistance) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        get has_depth() {
            return pb_1.Message.getField(this, 4) != null;
        }
        static fromObject(data: {
            transaction?: ReturnType<typeof dependency_2.co.topl.brambl.models.transaction.IoTransaction.prototype.toObject>;
            confidenceFactor?: ReturnType<typeof ConfidenceFactor.prototype.toObject>;
            blockId?: ReturnType<typeof dependency_4.co.topl.consensus.models.BlockId.prototype.toObject>;
            depth?: ReturnType<typeof ChainDistance.prototype.toObject>;
        }): TransactionReceipt {
            const message = new TransactionReceipt({});
            if (data.transaction != null) {
                message.transaction = dependency_2.co.topl.brambl.models.transaction.IoTransaction.fromObject(data.transaction);
            }
            if (data.confidenceFactor != null) {
                message.confidenceFactor = ConfidenceFactor.fromObject(data.confidenceFactor);
            }
            if (data.blockId != null) {
                message.blockId = dependency_4.co.topl.consensus.models.BlockId.fromObject(data.blockId);
            }
            if (data.depth != null) {
                message.depth = ChainDistance.fromObject(data.depth);
            }
            return message;
        }
        toObject() {
            const data: {
                transaction?: ReturnType<typeof dependency_2.co.topl.brambl.models.transaction.IoTransaction.prototype.toObject>;
                confidenceFactor?: ReturnType<typeof ConfidenceFactor.prototype.toObject>;
                blockId?: ReturnType<typeof dependency_4.co.topl.consensus.models.BlockId.prototype.toObject>;
                depth?: ReturnType<typeof ChainDistance.prototype.toObject>;
            } = {};
            if (this.transaction != null) {
                data.transaction = this.transaction.toObject();
            }
            if (this.confidenceFactor != null) {
                data.confidenceFactor = this.confidenceFactor.toObject();
            }
            if (this.blockId != null) {
                data.blockId = this.blockId.toObject();
            }
            if (this.depth != null) {
                data.depth = this.depth.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_transaction)
                writer.writeMessage(1, this.transaction, () => this.transaction.serialize(writer));
            if (this.has_confidenceFactor)
                writer.writeMessage(2, this.confidenceFactor, () => this.confidenceFactor.serialize(writer));
            if (this.has_blockId)
                writer.writeMessage(3, this.blockId, () => this.blockId.serialize(writer));
            if (this.has_depth)
                writer.writeMessage(4, this.depth, () => this.depth.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TransactionReceipt {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TransactionReceipt();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.transaction, () => message.transaction = dependency_2.co.topl.brambl.models.transaction.IoTransaction.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.confidenceFactor, () => message.confidenceFactor = ConfidenceFactor.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.blockId, () => message.blockId = dependency_4.co.topl.consensus.models.BlockId.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.depth, () => message.depth = ChainDistance.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): TransactionReceipt {
            return TransactionReceipt.deserialize(bytes);
        }
    }
    export class HeightData extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            height?: number;
            blockData?: BlockData;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("height" in data && data.height != undefined) {
                    this.height = data.height;
                }
                if ("blockData" in data && data.blockData != undefined) {
                    this.blockData = data.blockData;
                }
            }
        }
        get height() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set height(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get blockData() {
            return pb_1.Message.getWrapperField(this, BlockData, 2) as BlockData;
        }
        set blockData(value: BlockData) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_blockData() {
            return pb_1.Message.getField(this, 2) != null;
        }
        static fromObject(data: {
            height?: number;
            blockData?: ReturnType<typeof BlockData.prototype.toObject>;
        }): HeightData {
            const message = new HeightData({});
            if (data.height != null) {
                message.height = data.height;
            }
            if (data.blockData != null) {
                message.blockData = BlockData.fromObject(data.blockData);
            }
            return message;
        }
        toObject() {
            const data: {
                height?: number;
                blockData?: ReturnType<typeof BlockData.prototype.toObject>;
            } = {};
            if (this.height != null) {
                data.height = this.height;
            }
            if (this.blockData != null) {
                data.blockData = this.blockData.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.height != 0)
                writer.writeInt64(1, this.height);
            if (this.has_blockData)
                writer.writeMessage(2, this.blockData, () => this.blockData.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): HeightData {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new HeightData();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.height = reader.readInt64();
                        break;
                    case 2:
                        reader.readMessage(message.blockData, () => message.blockData = BlockData.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): HeightData {
            return HeightData.deserialize(bytes);
        }
    }
    export class BlockData extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            header?: dependency_5.co.topl.consensus.models.BlockHeader;
            body?: dependency_6.co.topl.node.models.FullBlockBody;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("header" in data && data.header != undefined) {
                    this.header = data.header;
                }
                if ("body" in data && data.body != undefined) {
                    this.body = data.body;
                }
            }
        }
        get header() {
            return pb_1.Message.getWrapperField(this, dependency_5.co.topl.consensus.models.BlockHeader, 1) as dependency_5.co.topl.consensus.models.BlockHeader;
        }
        set header(value: dependency_5.co.topl.consensus.models.BlockHeader) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_header() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get body() {
            return pb_1.Message.getWrapperField(this, dependency_6.co.topl.node.models.FullBlockBody, 4) as dependency_6.co.topl.node.models.FullBlockBody;
        }
        set body(value: dependency_6.co.topl.node.models.FullBlockBody) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        get has_body() {
            return pb_1.Message.getField(this, 4) != null;
        }
        static fromObject(data: {
            header?: ReturnType<typeof dependency_5.co.topl.consensus.models.BlockHeader.prototype.toObject>;
            body?: ReturnType<typeof dependency_6.co.topl.node.models.FullBlockBody.prototype.toObject>;
        }): BlockData {
            const message = new BlockData({});
            if (data.header != null) {
                message.header = dependency_5.co.topl.consensus.models.BlockHeader.fromObject(data.header);
            }
            if (data.body != null) {
                message.body = dependency_6.co.topl.node.models.FullBlockBody.fromObject(data.body);
            }
            return message;
        }
        toObject() {
            const data: {
                header?: ReturnType<typeof dependency_5.co.topl.consensus.models.BlockHeader.prototype.toObject>;
                body?: ReturnType<typeof dependency_6.co.topl.node.models.FullBlockBody.prototype.toObject>;
            } = {};
            if (this.header != null) {
                data.header = this.header.toObject();
            }
            if (this.body != null) {
                data.body = this.body.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_header)
                writer.writeMessage(1, this.header, () => this.header.serialize(writer));
            if (this.has_body)
                writer.writeMessage(4, this.body, () => this.body.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): BlockData {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new BlockData();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.header, () => message.header = dependency_5.co.topl.consensus.models.BlockHeader.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.body, () => message.body = dependency_6.co.topl.node.models.FullBlockBody.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): BlockData {
            return BlockData.deserialize(bytes);
        }
    }
}
